1）逃逸分析是什么、在编译管线哪里做？
定义：编译器在编译期决定一个变量/对象应放栈还是堆。只要能证明它不会在当前作用域之外被引用，就放在栈上，否则放堆上交给 GC。Go 的 EA 是编译器中间阶段对 IR/AST 做的数据流分析，与内联、去虚拟化等优化处在同一层次。
go.googlesource.com
+1

关键不变量（来自运行时/编译器注释）：(1) 堆里不能存向栈对象的指针；(2) 指向栈对象的指针不能超过该对象生命周期（函数返回或循环下一迭代等）。为保证这两点，Go 对函数体做静态数据流分析。
tip.golang.org

2）编译器“怎么判定会不会逃逸”？（底层原理）
Go 的 EA 用一张位置-位置（location graph）的加权有向图来建模所有“分配与赋值流向”：

节点（location）：每个能分配对象的语句/表达式（var、new/make、复合字面量等）对应一个“位置”。

边（assignment edges）：每个赋值都变成一条边；边的权重是“解引用次数 − 取地址次数”（称为 derefs）。例如：
p = &q 权重 -1；p = q 权重 0；p = *q 权重 1；p = **q 权重 2。
EA 顺着这张图找“可能把某位置的地址送到活得更久的地方”的路径，一旦发现，就把该位置标记为“必须堆分配”。
tip.golang.org

保守/非敏感性：为速度与简洁，Go 的实现“一般不做流敏感/路径敏感/上下文敏感区分”，也不区分结构体字段/切片元素（x.f = u[0] 会抽象成 x = *u）。但会记录切片索引的隐式解引用，并追踪循环深度（loopDepth）以处理循环短生命周期。
tip.golang.org

跨函数（过程间）分析：编译器为每个函数计算参数标记（parameter tags），总结“参数是否可能把指针流到堆/结果”。静态调用点会读取被调函数的这些标签，结合内联进一步推断；互递归函数在同一批次内联合分析。
tip.golang.org

闭包捕获：在遍历完函数体后，编译器根据上面的流信息决定闭包是“按值捕获”还是“按引用捕获”；按引用更易导致逃逸到堆。
tip.golang.org

强制堆分配的特殊情形：例如“很大的切片”之类情况，编译器会出于实现/安全原因直接打上“必须堆分配”。（见 HeapAllocReason 路径。）
tip.golang.org

小结：Go 不是通过“运行时探测”，而是编译期在一张“赋值/取址/解引用”的图上做到足够保守的判定，宁可多分配堆、不要漏分配导致悬垂指针。

3）“返回局部地址居然是合法的”？（常见误解）
Go 允许你返回局部变量的地址，因为若确实逃逸，编译器会把它自动放堆上，因此不会悬垂；这点在《Effective Go》有明确说明。
Go

4）最常见的“会逃逸”触发器（带可复制例子）
编译时用 go build -gcflags="-m=2" 观察（-m 打印优化决策，=2 打印更细）。Go 1.14 起细粒度 EA 诊断恢复可用，也支持 -json 机读日志。
Go
go.googlesource.com

把地址传到活得更久的地方（返回/赋给包级变量/存入堆驻留结构）

go
Copy
Edit
type Box struct{ P *int }

func f() *int {
    x := 10
    return &x // &x 必逃逸：返回后 x 的栈帧消失
}

var g Box
func h() {
    y := 20
    g.P = &y // &y 存入包级变量 -> 逃逸
}
典型输出：&x escapes to heap、&y escapes to heap。

闭包/协程捕获局部变量

go
Copy
Edit
func k() func() int {
    a := 0
    return func() int { a++; return a } // a 被闭包长活捕获 -> 逃逸
}
接口/反射路径：把小值装箱到 interface{}、传给 fmt/reflect 等往往在库内存活更久，常引发逃逸（具体取决于调用点是否可被内联+EA 看穿）。

把栈对象的指针放进切片/映射/通道，并把这些容器或指针流出当前作用域：容器在堆上或活得更久，里面的指针所指对象就必须在堆上。

go
Copy
Edit
func leakSlice() []*int {
    s := make([]*int, 0, 1) // s 本身可能在栈
    v := 1
    s = append(s, &v)       // 若 s 最终返回出函数，&v 需堆分配
    return s
}
必须长期存活的大对象/临时缓冲：例如超大 make([]byte, n) 可能被直接判为堆分配（实现细节）。
tip.golang.org

以“不透明”方式传给函数：若被调函数未内联且参数标签显示“可能泄漏到堆/结果”，调用点会按保守规则处理。这就是为什么开启/抑制内联有时会改变 EA 结果。
tip.golang.org

反例/不一定逃逸：把小 struct 按值传参通常不会触发逃逸；相比到处拿 &T，按值反而更可能保留在栈上（体量越小越成立）。

5）如何读懂 -gcflags=-m 输出？
常见信息含义（示意）：

moved to heap: x / x escapes to heap：变量 x 被判定需堆分配。

leaking param: p to result ~r0 level=0：参数 p 的指针流向返回值；调用点要据此做保守处理（或等待内联/跨函数标签消除）。

... inlining ...：若内联生效，EA 能“看穿”函数体，常把“看不懂”的逃逸消掉。

机器可读：-json 可导出 EA/内联/边界检查消除等事件（便于工具化查看）。
Go

6）与 cgo/汇编的“手动声明不逃逸”
//go:noescape（仅用于无函数体的声明，通常是汇编/外部实现）：告诉编译器“此函数不会让其指针参数逃逸”；EA 将据此允许把实参留在栈上。误用会造成未定义行为。
tip.golang.org

Go 1.24+ cgo 新增 #cgo noescape <CFunc> 与 #cgo nocallback <CFunc> 注解：前者声明“传给该 C 函数的 Go 指针不会逃逸”，后者声明“该 C 函数不会回调 Go”。这能减少不必要的堆化与保活，但同样需确保语义真实，否则风险极高。
tip.golang.org
Go Packages

7）工程实践：如何减少逃逸、减轻 GC 压力
优先按值而非到处取地址
小而频繁的对象（小 struct、短字符串）按值传递通常更好；只有当对象很大或确需共享/可变时再用指针。

让临时缓冲“待在函数里”
例如 bytes.Buffer/strings.Builder 尽量在单函数内创建—使用—释放，不把指向其内部数据的切片/指针泄漏到外层。

避免不必要的装箱/反射/fmt
热路径用专用函数替代通用接口；必要时让被调函数可内联，帮助 EA 看穿调用链。

容器逃逸意识
向外返回切片/映射/通道时，别把指向短命栈对象的指针塞进去；改为拷贝值或把被指对象设计为长命堆对象（由上层统一管理）。

用工具验证

用 -gcflags="-m=2" 看 EA 判定

搭配 pprof 分析 alloc_objects/alloc_space 热点

通过拆函数/调整内联阈值（实验性）验证“是否只是看不穿导致的保守堆化” 
Go

8）几个“微坑”与澄清
循环变量闭包：经典坑是 for i := range ... { go func(){ use i }() }；应 i := i 复值一份或把参数传入闭包，否则捕获同一地址，且更易触发逃逸。

把指针转成 uintptr：涉及 //go:uintptrescapes 语义的函数调用会强制保活/堆化，务必理解其文档与 runtime.KeepAlive 的契约。
Go Packages

“返回地址就一定慢”并不总成立：性能取决于是否触发堆化与 GC 压力、是否阻断内联等；小对象按值返回往往更好。

“栈 > 堆”不是绝对：有时为了减少拷贝/共享大对象，有意识地在上层集中堆化更好，关键是“可控、可测”。

9）把握“会不会逃逸”的两条硬规则
只要有路径把某个对象的地址送到“活得更久”的地方（堆、结果、全局、长活容器/闭包/其他 goroutine），它就会被判为堆分配。

编译器宁可保守：Go 的 EA 一般不做字段/路径敏感精细建模，所以一些“理论上可栈化”的情况，若分析看不穿，也会被保守地堆化。