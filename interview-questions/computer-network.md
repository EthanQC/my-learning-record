## 问题列表
#### 协议模型与资源传递
* TCP/IP 网络模型有哪几层？
* TCP/IP 模型和 OSI 模型分别是什么？它们之间有什么区别？
* 在浏览器中从输入 URL 到页面展示发生了什么？
* Linux 系统是如何收发网络包的？

#### HTTP 与 HTTPS
* HTTP 是什么？
* HTTP 常见的状态码有哪些？
* HTTP 常见字段有哪些？
* GET 和 POST 有什么区别？
* GET 和 POST 方法都是安全和幂等的吗？
* HTTP 缓存有哪些实现方式？
* 什么是强制缓存？
* 什么是协商缓存？
* HTTP/1.1 的优缺点分别有哪些？
* HTTP/1.1 的性能如何？
* HTTP 与 HTTPS 有哪些区别？
* HTTPS 解决了 HTTP 的哪些问题？
* HTTPS 是如何建立连接的？其间交互了什么？
* HTTPS 的应用数据是如何保证完整性的？
* HTTPS 一定安全可靠吗？
* HTTP/1.1 相比 HTTP/1.0 提高了什么性能？
* HTTP/2 做了什么优化？
* HTTP/3 做了哪些优化？
* HTTP/1.1 如何优化？
* HTTPS RSA 的握手过程是什么？
* HTTPS ECDHE 的握手过程是什么？
* HTTPS 如何优化？
* 既然有 HTTP 协议，为什么还要有 RPC 和 WebSocket？
* HTTPS 为什么安全？
* 给你看一个数字证书，说说上面都有什么内容
* 介绍一下 HTTPS
* 为什么要同时使用公钥和私钥，这两个密钥有什么用

#### TCP 与 UDP
* TCP 头格式有哪些？
* 为什么需要 TCP 协议？TCP 工作在哪一层？
* 什么是 TCP？
* 什么是 TCP 连接？
* 如何唯一确定一个 TCP 连接呢？
* 你知道 TCP 和 UDP 吗？它们的区别是什么？分别的应用场景是？
* TCP 和 UDP 可以使用同一个端口吗？
* TCP 三次握手过程是什么样的？
* 如何在 Linux 系统中查看 TCP 状态？
* 为什么 TCP 是三次握手而不是两次或者四次？
* 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？
* 初始序列号 ISN 是如何随机产生的？
* 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
* 第一次握手如果丢失了，会发生什么？
* 第二次握手如果丢失了，会发生什么？
* 第三次握手如果丢失了，会发生什么？
* 什么是 SYN 攻击？该如何避开？
* TCP 四次挥手的过程是什么样的？
* 为什么挥手需要四次？
* 第一次挥手丢失了，会发生什么？
* 第二次挥手丢失了，会发生什么？
* 第三次挥手丢失了，会发生什么？
* 第四次挥手丢失了，会发生什么？
* 为什么 TIME_WAIT 等待的时间是 2 MSL？
* 为什么需要 TIME_WAIT 状态？
* TIME_WAIT 过多有什么危害？
* 如何优化 TIME_WAIT？
* 服务器出现大量 TIME_WAIT 状态的原因有哪些？
* 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？
* 如果已经建立了连接，但是客户端突然出现故障了怎么办？
* 如果已经建立了连接，但是服务端的进程崩溃会发生什么？
* 针对 TCP 应该如何 Socket 编程？
* listen 时候参数 backlog 的意义？
* accept 发生在三次握手的哪一步？
* 客户端调用 close 了，连接是断开的流程是什么？
* 没有 accept，能建立 TCP 连接吗？
* 没有 listen，能建立 TCP 连接吗？
* TCP 的重传机制是什么？
* TCP 的滑动窗口是什么？
* TCP 的流量和拥塞控制是什么？
* 什么是 TCP 半连接队列和全连接队列？
* 如何优化 TCP？

#### IP
* 

#### 同步相关
* 类似抖音直播间，如果有十万人同时在线，该如何做直播间点赞同步操作
* 直播间突然有大流量打过来，现有的服务器资源只能维持现状，该怎么办
* 有没有了解过看门狗机制

#### 游戏开发相关
* **在开发游戏的时候 TCP 和 UDP 用哪个比较好？**
* 那比如当前一帧我要发送大量的数据，用 TCP 会有什么问题？或者说 TCP 相较于 UDP 的不足之处是什么？

## 协议模型与资源传递
#### Q：TCP/IP 网络模型有哪几层？

从上到下分为**应用层、传输层、网络层和链路层**共**四层**

**应用层**直接面向用户或应用程序，定义应用数据格式、会话控制以及具体业务协议，用于实现各种网络应用，常见的协议有 HTTP/HTTPS(Web)、DNS（域名解析）、SMTP（电子邮件）、FTP/SFTP（文件传输）、SSH（远程登录）、Telnet、SNMP（网络管理）等

**传输层**在端到端间提供可靠或不可靠的数据传输服务，包括端口复用、流量控制、差错校验与重传等，常见协议有 TCP（Transmission Control Protocol，面向连接、可靠传输，提供流量控制、拥塞控制、顺序交付）、UDP（User Datagram Protocol，无连接、尽最大努力交付，开销小、实时性好）、QUIC（基于 UDP 的新一代传输协议，集成了加密和多路复用特性）

**网络层**负责主机间分组的选路与转发，即将数据包从源地址送到目标地址，跨越一个或多个网络，并提供逻辑寻址（IP 地址），常见协议有 IP（Internet Protocol，IPv4、IPv6，负责分组的寻址与转发）、ICMP（Internet Control Message Protocol，用于差错报告、网络探测）、IGMP（Internet Group Management Protocol，管理多播组成员关系等）

**链路层**负责在物理介质（网线、光纤、无线等）上封装和发送数据帧，实现相邻网络设备（如交换机、路由器接口、网卡）之间的可靠通信，常见协议有 Ethernet（以太网）、Wi-Fi（802.11）、PPP、ARP（地址解析协议，虽为网络层辅助协议，但通常归到链路层处理 MAC 映射）等

#### Q：TCP/IP 模型和 OSI 模型分别是什么？它们之间有什么区别？

**OSI**（Open Systems Interconnection）**模型**由国际标准化组织制定，将网络通信抽象为**七层**，每层职责清晰，利于教学与协议设计，从上到下依次分为应用层、表示层、会话层、传输层、网络层、数据链路层和物理层

应用层为应用程序提供网络服务接口，定义应用协议（如 HTTP、FTP、SMTP）；表示层负责数据格式转换、加密／解密、压缩／解压；会话层负责会话管理（建立、维护、终止会话）、全双工/半双工控制；传输层负责端到端传输管理：可靠性（TCP）、不可靠传输（UDP）、端口复用；网络层负责路由与转发，逻辑寻址（IP）、分组交换；数据链路层负责帧封装与链路管理，MAC 寻址，差错检测（如 CRC）、流量控制；物理层负责物理介质传输比特流：电气、光学、机械接口标准

TCP/IP 模型也称作互联网协议族模型，更贴近实际网络协议栈的实现，分为四层：应用层、传输层、网络层和链路层；应用层是	各种网络应用协议，传输层是 TCP（可靠）、UDP（无连接）、端口复用，网络层是 IP 路由转发、报文分片与重组；ICMP、IGMP 等，链路层是以太网/Wi-Fi 帧封装、MAC 寻址、ARP 等

TCP/IP 模型是实际的协议栈，更贴近工程实现，结构更简洁，直接对应主流协议实现，更加实践化、工程化，更偏重具体应用协议，更注重协议性能和互操作，全互联网设备普遍使用；OSI 模型是强调每层独立职责，层次分明，适合理论教学和协议标准化，不同厂商或协议的实现可在各层内替换而互不影响，主要是理论参考，便于学习、标准化，更偏重数据格式与会话控制，每层职责严谨，可替换性强

#### Q：在浏览器中从输入 URL 到页面展示发生了什么？



#### Q：Linux 系统是如何收发网络包的？



## HTTP 与 HTTPS
**Q：HTTPS 为什么安全？**

A：HTTPS 通过 TLS 实现加密、完整性校验和身份认证，支持前向安全，它在握手阶段以服务器证书公钥完成非对称密钥交换，协商会话密钥，随后的业务报文用对称算法加密并附带 MAC 校验，浏览器会对证书链和域名做验证

**Q：一个数字证书上面一般都会有什么内容？**

A：证书通常含版本、序列号、签名算法、颁发者 Issuer、主体域名/组织、有效期、公钥信息、指纹摘要及扩展、颁发者数字签名等，客户端会验证签名并校验证书链与有效期

**Q：介绍一下 HTTPS**

A：HTTPS 是在 HTTP 的基础上加入了 TLS 或者说 SSL 加密的通信协议，默认走 TCP 443 端口，它的核心在于握手阶段，客户端发 ClientHello，服务器选定加密套件并返回证书，客户端验证证书合法后，用非对称加密协商出对称密钥，最后双方互发 Finished 消息确认；握手完成后，所有数据都通过对称加密和消息认证码进行保护，并用 ECDHD 提供前向安全，保证机密性、完整性和服务器身份认证；相比 HTTP 的明文传输，虽然 HTTPS 增加了握手开销，但一次握手后就能复用会话，还支持 http 2 的多路复用

**Q：为什么要同时使用公钥和私钥，这两个密钥有什么用**

A：公钥和私钥一对是非对称加密的基础，用对方的公钥加密能确保只有拥有对应私钥的那一端才能解密查看，用自己的私钥对数据签名，让对方通过我的公钥来验证，保证消息确实来自我并且没有被篡改，在 HTTPS 中，服务器把公钥打包在 CA 签发的证书里，客户端验证证书无误后，用该公钥校验服务器私钥对握手数据的签名，再用公钥加密，只有服务器私钥能解开，这样既验证了服务器身份，也保证了后续通信的机密性和完整性

## 同步相关
**Q：类似抖音直播间，如果有十万人同时在线，该如何做直播间点赞同步操作？**

A：嗯在这种高并发的场景下，肯定不能使用逐条广播，我会采用异步批量聚合 + 发布或订阅 + websocket 集群广播的方案，首先客户端通过 websocket 将点赞事件写入消息队列，消息队列可以用 Kafka 或 redis stream，然后再使用专门的聚合服务按照某个时间比如 100ms 为单位，把同一房间的点赞事件在内存里累加，然后原子性地存到 redis，更新后再通过 redis pub 或 sub 发布最新总数，然后所有 websocket 节点订阅该房间的更新频道，收到后只发一条点赞更新消息给该房间的所有客户端，客户端拿到最新的点赞数后再更新渲染 UI，这样就保证了高可用和消息可靠，扩展性也比较好，也有一定的容错性

**Q：直播间突然有大流量打过来，现有的服务器资源只能维持现状，该怎么办？**

A：感觉主要还是要先快速降级和限流保护，比如说可以先把一些非核心的功能关闭，可以限制每个用户的请求频率，或者是限制每个房间的并发连接数等，比如说点赞、评论等，或者是把一些非必要的请求丢弃掉，比如说可以把一些低优先级的请求放到消息队列中，等有空余资源时再处理；另外也可以考虑使用 CDN 来缓存一些静态资源，减轻服务器的压力；如果还是不行的话就只能考虑扩容了，比如说可以增加一些新的服务器节点，或者是使用负载均衡来分担流量；如果还是不行的话就只能考虑限流了
如果直播间突然来了超出现有资源的大流量，我会第一时间开启限流与降级，关停非核心功能，优先保证视频推流和互动。接着把所有操作请求写入消息队列，后端按能力排队处理，避免打穿数据库。静态资源和 HLS 流都走 CDN，减轻源站；应用层做本地＋Redis 多级缓存。
同时，我会触发 Kubernetes 的水平弹性伸缩，快速拉新实例，如果资源仍不足，就用 Serverless 函数临时卸载热点请求。事后结合 Prometheus 告警与容量预案，优化压测脚本，确保下次大流量到来时，我们可以平滑度过。

**Q：有没有了解过看门狗机制？**

A：看门狗本质上是一种定时器，用来监控运行状态，系统或服务在正常运行时会不断喂狗，如果在规定时间内没有收到喂狗信号，看门狗就会认定系统卡死或者异常，后端方面主要是操作系统或进程的软件看门狗或者云和容器平台的软件看门狗，如果主逻辑超时没有相应，看门狗线程就会执行自我修复逻辑，比如重启、释放资源、告警等

## 游戏开发相关
**Q：在开发游戏的时候 TCP 和 UDP 用哪个比较好？**

A：

**Q：那比如当前一帧我要发送大量的数据，用 TCP 会有什么问题？或者说 TCP 相较于 UDP 的不足之处是什么？**

A：