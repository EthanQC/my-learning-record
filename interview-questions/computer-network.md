# 问题列表
#### 协议模型与资源传递
* TCP/IP 网络模型有哪几层？
* TCP/IP 模型和 OSI 模型分别是什么？它们之间有什么区别？
* 在浏览器中从输入 URL 到页面展示发生了什么？
* Linux 系统是如何收发网络包的？

#### HTTP 与 HTTPS
* HTTP 是什么？
* HTTP 常见的状态码有哪些？
* HTTP 常见字段有哪些？
* GET 和 POST 有什么区别？
* GET 和 POST 方法都是安全和幂等的吗？
* HTTP 缓存有哪些实现方式？
* 什么是强制缓存？
* 什么是协商缓存？
* HTTP/1.1 的优缺点分别有哪些？
* HTTP/1.1 的性能如何？
* HTTP 与 HTTPS 有哪些区别？
* HTTPS 解决了 HTTP 的哪些问题？
* HTTPS 是如何建立连接的？其间交互了什么？
* HTTPS 的应用数据是如何保证完整性的？
* HTTPS 一定安全可靠吗？
* HTTP/1.1 相比 HTTP/1.0 提高了什么性能？
* HTTP/2 做了什么优化？
* HTTP/3 做了哪些优化？
* HTTP/1.1 如何优化？如何避免发送 HTTP 请求？如何减少 HTTP 请求次数？如何减少 HTTP 响应的数据大小？
* HTTPS RSA 的握手过程是什么？
* HTTPS ECDHE 的握手过程是什么？
* HTTPS 如何优化？
* 既然有 HTTP 协议，为什么还要有 RPC 和 WebSocket 协议？
* HTTPS 为什么安全？
* 给你看一个数字证书，说说上面都有什么内容
* 介绍一下 HTTPS
* 为什么要同时使用公钥和私钥，这两个密钥有什么用

#### TCP 与 UDP
* TCP 头格式有哪些？
* 为什么需要 TCP 协议？TCP 工作在哪一层？
* 什么是 TCP？
* 什么是 TCP 连接？
* 如何唯一确定一个 TCP 连接呢？
* 你知道 TCP 和 UDP 吗？它们的区别是什么？分别的应用场景是？
* TCP 和 UDP 可以使用同一个端口吗？
* TCP 三次握手过程是什么样的？
* 如何在 Linux 系统中查看 TCP 状态？
* 为什么 TCP 是三次握手而不是两次或者四次？
* 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？
* 初始序列号 ISN 是如何随机产生的？
* 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
* 第一次握手如果丢失了，会发生什么？
* 第二次握手如果丢失了，会发生什么？
* 第三次握手如果丢失了，会发生什么？
* 什么是 SYN 攻击？该如何避开？
* TCP 四次挥手的过程是什么样的？
* 为什么挥手需要四次？
* 第一次挥手丢失了，会发生什么？
* 第二次挥手丢失了，会发生什么？
* 第三次挥手丢失了，会发生什么？
* 第四次挥手丢失了，会发生什么？
* 为什么 TIME_WAIT 等待的时间是 2 MSL？
* 为什么需要 TIME_WAIT 状态？
* TIME_WAIT 过多有什么危害？
* 如何优化 TIME_WAIT？
* 服务器出现大量 TIME_WAIT 状态的原因有哪些？
* 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？
* 如果已经建立了连接，但是客户端突然出现故障了怎么办？
* 如果已经建立了连接，但是服务端的进程崩溃会发生什么？
* 针对 TCP 应该如何 Socket 编程？
* listen 时候参数 backlog 的意义？
* accept 发生在三次握手的哪一步？
* 客户端调用 close 了，连接是断开的流程是什么？
* 没有 accept，能建立 TCP 连接吗？
* 没有 listen，能建立 TCP 连接吗？
* TCP 的重传、滑动窗口、流量控制和拥塞控制分别是什么？详细说说
* TCP 的流量和拥塞控制是什么？
* 什么是 TCP 队头阻塞问题？
* 什么是 TCP 半连接队列和全连接队列？
* 如何优化 TCP？
* 如何理解 TCP 是面向字节流协议？如何理解字节流？如何解决粘包？
* 为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？
* SYN 报文什么时候情况下会被丢弃？
* 已建立连接的TCP，收到SYN会发生什么？
* 如何关闭一个 TCP 连接？
* 四次挥手中收到乱序的 FIN 包会如何处理？
* 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？
* 在 TIME_WAIT 状态的 TCP 连接，收到 RST 会断开连接吗？
* TCP 连接，一端断电和进程崩溃有什么区别？
* 拔掉网线后， 原本的 TCP 连接还存在吗？
* tcp_tw_reuse 为什么默认是关闭的？什么是 TIME_WAIT 状态？为什么要设计 TIME_WAIT 状态？tcptwreuse 是什么？为什么 tcptwreuse 默认是关闭的？
* HTTPS 中 TLS 和 TCP 能同时握手吗？
* TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？
* TCP 协议有什么缺陷？
* 如何基于 UDP 协议实现可靠传输？
* QUIC 是如何实现可靠传输的？
* QUIC 是如何解决 TCP 队头阻塞问题的？
* QUIC 是如何做流量控制的？
* QUIC 是如何迁移连接的？
* TCP 和 UDP 可以使用同一个端口吗？TCP 和 UDP 可以同时绑定相同的端口吗？
* 多个 TCP 服务进程可以绑定同一个端口吗？
* 客户端的端口可以重复使用吗？
* 服务端没有 listen，客户端发起连接建立，会发生什么？
* 不使用 listen ，可以建立 TCP 连接吗？
* 没有 accept，能建立 TCP 连接吗？
* 用了 TCP 协议，数据一定不会丢吗？如果会的话，该怎么解决？
* TCP 四次挥手，可以变成三次吗？什么情况会出现三次挥手？
* TCP 序列号和确认号是如何变化的？

#### IP
* 

#### 同步相关情景题
* 类似抖音直播间，如果有十万人同时在线，该如何做直播间点赞同步操作
* 直播间突然有大流量打过来，现有的服务器资源只能维持现状，该怎么办
* 有没有了解过看门狗机制

#### 游戏开发相关
* **在开发游戏的时候 TCP 和 UDP 用哪个比较好？**
* 那比如当前一帧我要发送大量的数据，用 TCP 会有什么问题？或者说 TCP 相较于 UDP 的不足之处是什么？

# 解答
## 协议模型与资源传递
#### Q：TCP/IP 网络模型有哪几层？

从上到下分为**应用层、传输层、网络层和链路层**共**四层**

**应用层**直接面向用户或应用程序，定义应用数据格式、会话控制以及具体业务协议，用于实现各种网络应用，常见的协议有 HTTP/HTTPS(Web)、DNS（域名解析）、SMTP（电子邮件）、FTP/SFTP（文件传输）、SSH（远程登录）、Telnet、SNMP（网络管理）等

**传输层**在端到端间提供可靠或不可靠的数据传输服务，包括端口复用、流量控制、差错校验与重传等，常见协议有 TCP（Transmission Control Protocol，面向连接、可靠传输，提供流量控制、拥塞控制、顺序交付）、UDP（User Datagram Protocol，无连接、尽最大努力交付，开销小、实时性好）、QUIC（基于 UDP 的新一代传输协议，集成了加密和多路复用特性）

**网络层**负责主机间分组的选路与转发，即将数据包从源地址送到目标地址，跨越一个或多个网络，并提供逻辑寻址（IP 地址），常见协议有 IP（Internet Protocol，IPv4、IPv6，负责分组的寻址与转发）、ICMP（Internet Control Message Protocol，用于差错报告、网络探测）、IGMP（Internet Group Management Protocol，管理多播组成员关系等）

**链路层**负责在物理介质（网线、光纤、无线等）上封装和发送数据帧，实现相邻网络设备（如交换机、路由器接口、网卡）之间的可靠通信，常见协议有 Ethernet（以太网）、Wi-Fi（802.11）、PPP、ARP（地址解析协议，虽为网络层辅助协议，但通常归到链路层处理 MAC 映射）等

#### Q：TCP/IP 模型和 OSI 模型分别是什么？它们之间有什么区别？

**OSI**（Open Systems Interconnection）**模型**由国际标准化组织制定，将网络通信抽象为**七层**，每层职责清晰，利于教学与协议设计，从上到下依次分为应用层、表示层、会话层、传输层、网络层、数据链路层和物理层

**应用层**为应用程序提供网络服务接口，定义应用协议（如 HTTP、FTP、SMTP）；**表示层**负责数据格式转换、加密／解密、压缩／解压；**会话层**负责会话管理（建立、维护、终止会话）、全双工/半双工控制；**传输层**负责端到端传输管理：可靠性（TCP）、不可靠传输（UDP）、端口复用；**网络层**负责路由与转发，逻辑寻址（IP）、分组交换；**数据链路层**负责帧封装与链路管理，MAC 寻址，差错检测（如 CRC）、流量控制；**物理层**负责物理介质传输比特流：电气、光学、机械接口标准

**TCP/IP 模型**也称作互联网协议族模型，更贴近实际网络协议栈的实现，分为**四层**：**应用层、传输层、网络层和链路层**；**应用层**是	各种网络应用协议，**传输层**是 TCP（可靠）、UDP（无连接）、端口复用，**网络层**是 IP 路由转发、报文分片与重组；ICMP、IGMP 等，**链路层**是以太网/Wi-Fi 帧封装、MAC 寻址、ARP 等

**TCP/IP 模型**是实际的协议栈，更贴近工程实现，结构更简洁，直接对应主流协议实现，更加实践化、工程化，更偏重具体应用协议，更注重协议性能和互操作，全互联网设备普遍使用；**OSI 模型**是强调每层独立职责，层次分明，适合理论教学和协议标准化，不同厂商或协议的实现可在各层内替换而互不影响，主要是理论参考，便于学习、标准化，更偏重数据格式与会话控制，每层职责严谨，可替换性强

#### Q：在浏览器中从输入 URL 到页面展示发生了什么？

输入 URL → 检查本地缓存 → 解析 DNS（可能命中 CDN 边缘）→ 建立连接（TCP+TLS 或 QUIC/TLS）→ 发送 HTTP 请求 → CDN/负载均衡/反向代理/WAF → 应用处理并返回（含缓存/压缩/ETag 等）→ 浏览器并行拉资源（H2/H3 多路复用、优先级）→ 构建 DOM/CSSOM → 生成渲染树、布局、绘制、合成（JS/CSS 的阻塞与优化）→ 页面可见（FCP/LCP）→ 后续异步资源与交互就绪

#### Q：Linux 系统是如何收发网络包的？

**收包**：NIC 把数据 DMA 到环形缓冲 → 触发中断 → NAPI 轮询把包拉进内核 → GRO/校验 → 进入协议栈 → Netfilter（PREROUTING）→ 路由判定（给本机/转发）→ L4（TCP/UDP）→ 送入对应 socket 队列 → 应用 recv() 拿数据

**发包**：应用 send() → 协议栈组包（拥塞控制、分段、校验）→ 路由与邻居解析（ARP/ND）→ Netfilter（OUTPUT/POSTROUTING）→ qdisc 排队/整形 → NIC TX 队列（TSO/校验 offload）→ DMA 下发到线

## HTTP 与 HTTPS
#### Q：HTTP 是什么？

**HTTP**（HyperText Transfer Protocol） 是一种**应用层、请求-响应式（客户端发请求，服务端回相应）、面向资源**的协议，用于在客户端与服务端之间传输数据

它本身**无连接、无状态（每个请求独立）**（会话靠 Cookie/Token/Session 存在应用层），通过 URL/URI 标识资源，用 方法（GET/POST/PUT/DELETE…）表达意图，用状态码表达结果，配合头部与缓存语义完成内容协商、压缩、鉴权、缓存等

协议在 HTTP/1.1→HTTP/2→HTTP/3(QUIC) 演进中提升性能与可靠性，安全版是 HTTPS（HTTP over TLS）

#### Q：HTTP 常见的状态码有哪些？

##### 1xx 信息
* 100 Continue：配合大 Body；服务端允许继续传
* 101 Switching Protocols：WebSocket 升级
* 103 Early Hints：提早下发 Link: rel=preload 加速首屏

##### 2xx 成功
* 200 OK：常规成功
* 201 Created：创建资源（务必带 Location 指向新资源）
* 202 Accepted：异步受理（排队中，结果稍后）
* 204 No Content：成功但无响应体（删除/幂等更新）
* 206 Partial Content：配合 Range 断点续传

##### 3xx 重定向 / 缓存
* 301 vs 308：永久重定向；308 保持方法（POST 仍 POST）
* 302/307/303：临时；307 保持方法，303 强制 GET（表单/支付回跳）
* 304 Not Modified：命中协商缓存（ETag/If-None-Match 或 Last-Modified）

##### 4xx 客户端错误
* 400 Bad Request：参数/格式不对
* 401 Unauthorized：未认证（通常带 WWW-Authenticate），有登录后还不许看是 403
* 403 Forbidden：已认证但无权限/被阻断
* 404 Not Found：资源不存在/隐藏实现细节
* 405 Method Not Allowed：记得回 Allow: GET,POST
* 408 Request Timeout：客户端太慢
* 409 Conflict：版本冲突/资源状态冲突（如并发更新）
* 410 Gone：资源永久移除（SEO 友好）
* 412 Precondition Failed：条件更新失败（配 If-Match 做乐观锁）
* 413/414/415：体积过大/URI 过长/媒体类型不支持
* 422 Unprocessable Entity：语义校验失败（字段合法但不满足业务规则；JSON API/REST 常用）
* 429 Too Many Requests：限流，务必带 Retry-After

##### 5xx 服务端/网关
* 500 Internal Server Error：兜底，别滥用
* 501 Not Implemented：方法未实现
* 502 Bad Gateway：反向代理收到上游异常
* 503 Service Unavailable：过载/维护，可带 Retry-After
* 504 Gateway Timeout：上游超时（区分应用内超时 vs 网关超时）

#### Q：HTTP 常见字段有哪些？



#### Q：GET 和 POST 有什么区别？



#### Q：GET 和 POST 方法都是安全和幂等的吗？



#### Q：HTTP 缓存有哪些实现方式？



#### Q：什么是强制缓存？



#### Q：什么是协商缓存？



#### Q：HTTP/1.1 的优缺点分别有哪些？



#### Q：HTTP/1.1 的性能如何？



#### Q：HTTP 与 HTTPS 有哪些区别？



#### Q：HTTPS 解决了 HTTP 的哪些问题？



#### Q：HTTPS 是如何建立连接的？其间交互了什么？



#### Q：HTTPS 的应用数据是如何保证完整性的？



#### Q：HTTPS 一定安全可靠吗？



* HTTP/1.1 相比 HTTP/1.0 提高了什么性能？
* HTTP/2 做了什么优化？
* HTTP/3 做了哪些优化？
* HTTP/1.1 如何优化？如何避免发送 HTTP 请求？如何减少 HTTP 请求次数？如何减少 HTTP 响应的数据大小？
* HTTPS RSA 的握手过程是什么？
* HTTPS ECDHE 的握手过程是什么？
* HTTPS 如何优化？
* 既然有 HTTP 协议，为什么还要有 RPC 和 WebSocket 协议？

**Q：HTTPS 为什么安全？**

A：HTTPS 通过 TLS 实现加密、完整性校验和身份认证，支持前向安全，它在握手阶段以服务器证书公钥完成非对称密钥交换，协商会话密钥，随后的业务报文用对称算法加密并附带 MAC 校验，浏览器会对证书链和域名做验证

**Q：一个数字证书上面一般都会有什么内容？**

A：证书通常含版本、序列号、签名算法、颁发者 Issuer、主体域名/组织、有效期、公钥信息、指纹摘要及扩展、颁发者数字签名等，客户端会验证签名并校验证书链与有效期

**Q：介绍一下 HTTPS**

A：HTTPS 是在 HTTP 的基础上加入了 TLS 或者说 SSL 加密的通信协议，默认走 TCP 443 端口，它的核心在于握手阶段，客户端发 ClientHello，服务器选定加密套件并返回证书，客户端验证证书合法后，用非对称加密协商出对称密钥，最后双方互发 Finished 消息确认；握手完成后，所有数据都通过对称加密和消息认证码进行保护，并用 ECDHD 提供前向安全，保证机密性、完整性和服务器身份认证；相比 HTTP 的明文传输，虽然 HTTPS 增加了握手开销，但一次握手后就能复用会话，还支持 http 2 的多路复用

**Q：为什么要同时使用公钥和私钥，这两个密钥有什么用**

A：公钥和私钥一对是非对称加密的基础，用对方的公钥加密能确保只有拥有对应私钥的那一端才能解密查看，用自己的私钥对数据签名，让对方通过我的公钥来验证，保证消息确实来自我并且没有被篡改，在 HTTPS 中，服务器把公钥打包在 CA 签发的证书里，客户端验证证书无误后，用该公钥校验服务器私钥对握手数据的签名，再用公钥加密，只有服务器私钥能解开，这样既验证了服务器身份，也保证了后续通信的机密性和完整性

## 同步相关
**Q：类似抖音直播间，如果有十万人同时在线，该如何做直播间点赞同步操作？**

A：嗯在这种高并发的场景下，肯定不能使用逐条广播，我会采用异步批量聚合 + 发布或订阅 + websocket 集群广播的方案，首先客户端通过 websocket 将点赞事件写入消息队列，消息队列可以用 Kafka 或 redis stream，然后再使用专门的聚合服务按照某个时间比如 100ms 为单位，把同一房间的点赞事件在内存里累加，然后原子性地存到 redis，更新后再通过 redis pub 或 sub 发布最新总数，然后所有 websocket 节点订阅该房间的更新频道，收到后只发一条点赞更新消息给该房间的所有客户端，客户端拿到最新的点赞数后再更新渲染 UI，这样就保证了高可用和消息可靠，扩展性也比较好，也有一定的容错性

**Q：直播间突然有大流量打过来，现有的服务器资源只能维持现状，该怎么办？**

A：感觉主要还是要先快速降级和限流保护，比如说可以先把一些非核心的功能关闭，可以限制每个用户的请求频率，或者是限制每个房间的并发连接数等，比如说点赞、评论等，或者是把一些非必要的请求丢弃掉，比如说可以把一些低优先级的请求放到消息队列中，等有空余资源时再处理；另外也可以考虑使用 CDN 来缓存一些静态资源，减轻服务器的压力；如果还是不行的话就只能考虑扩容了，比如说可以增加一些新的服务器节点，或者是使用负载均衡来分担流量；如果还是不行的话就只能考虑限流了
如果直播间突然来了超出现有资源的大流量，我会第一时间开启限流与降级，关停非核心功能，优先保证视频推流和互动。接着把所有操作请求写入消息队列，后端按能力排队处理，避免打穿数据库。静态资源和 HLS 流都走 CDN，减轻源站；应用层做本地＋Redis 多级缓存。
同时，我会触发 Kubernetes 的水平弹性伸缩，快速拉新实例，如果资源仍不足，就用 Serverless 函数临时卸载热点请求。事后结合 Prometheus 告警与容量预案，优化压测脚本，确保下次大流量到来时，我们可以平滑度过。

**Q：有没有了解过看门狗机制？**

A：看门狗本质上是一种定时器，用来监控运行状态，系统或服务在正常运行时会不断喂狗，如果在规定时间内没有收到喂狗信号，看门狗就会认定系统卡死或者异常，后端方面主要是操作系统或进程的软件看门狗或者云和容器平台的软件看门狗，如果主逻辑超时没有相应，看门狗线程就会执行自我修复逻辑，比如重启、释放资源、告警等

## 游戏开发相关
**Q：在开发游戏的时候 TCP 和 UDP 用哪个比较好？**

A：

**Q：那比如当前一帧我要发送大量的数据，用 TCP 会有什么问题？或者说 TCP 相较于 UDP 的不足之处是什么？**

A：