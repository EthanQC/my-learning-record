## 原子操作、锁、并发与多线程编程
**Q：智能指针的引用计数在多线程环境下如何实现线程安全？其开销如何？**

A：通过使用atomic头文件引入原子变量实现原子操作，保证引用计数同一时刻只能有单个线程操作，从而实现线程安全；一般来说其开销相对不高，基本上是硬件级别的低消耗，但在高并发场景下遇到多个线程对引用计数频繁修改时，可能会遇到瓶颈

**Q：你如何处理数据竞争和死锁？对 lock-free 结构有了解吗？**

A：数据竞争我一般就是用互斥锁，c++中就是mutex，通过互斥锁来避免多个线程同时操作同一块数据，死锁的话我一般不会在实际开发中遇到，因为如果有需要加锁的场景我就会比较注意设计锁的逻辑，通过避免循环引用来避免死锁，如果死锁真的发生了我记得之前有看到过就是mutex好像有提供一个能获取所有锁的函数，获取之后再一个个解锁就好；lock-free结构主要是原子性相关的，通过硬件层面避免竞争来实现类似于锁的效果，它很好地避免了使用锁可能会出现的死锁问题，同时它简单轻便，不像锁那样复杂，而且性能会比使用锁更好一些

**Q：“原子操作”在你的项目里实际应用过吗？在哪里用？为什么用它而不是互斥锁？**

A：在我项目中的原子操作其实更多的就是用来避免数据竞争，比如刚刚提到的智能指针的引用计数，可以通过原子性的操作来保证线程安全，再就是一些相对轻量或简单的场景，比如socket实时通信中用它来避免死锁等；用它最主要的原因就是它简单好用，高性能，可以避免使用锁带来的一些问题，同时适用于轻量级的场景

## 移动语义
**Q：移动语义具体在什么场景中发挥了多大性能优势？能举出你项目中的例子吗？**

A：移动语义主要是用在返回大对象或者调整数组大小这种需要避免深拷贝来提升性能的场景，比如一个有十万条数据的vector，如果用拷贝可能需要时间在毫秒级别，但如果使用移动语义则可以到达微秒级别；我这份简历上用到的其实不多，我有了解到比如某个游戏场景中资源的记录就可以用移动语义来提高性能，我另一个实时通信的项目是用到移动语义来在多个socket之间快速移动标识符，以达到提高性能的目的