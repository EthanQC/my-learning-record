## 问题列表
#### 语言基础
* 和 C++ 对比介绍一下 Go 语言的特点和优势？
* go 包管理的方式有哪些？
* go 支持重载吗？如何在 go 中实现一个方法的重载？
* go 语言中如何实现继承？
* go 语言中如何实现多态？
* map 和 slice 作为参数传递时会遇到什么问题？
* Go 语言中 struct 和 class 有什么区别？
* 讲讲 go 的错误处理机制？
* 讲讲 go 里面常见的数据类型？
* 在你日常使用 go 语言开发时有什么注意事项或者遇到过哪些问题吗？
* 在 go 语言中什么时候会需要性能调优？

#### 垃圾回收
* new 和 make 的区别是什么？
* 讲讲 GC 垃圾回收和内存逃逸？
* go routine什么情况会发生内存泄漏？如何避免？
* 常见的 GC 实现方式有哪些？
* Go 垃圾回收（GC）的触发条件是什么？
* Go语言中的 GC 流程？
* go 的垃圾回收机制了解吗？
* GC 如何调优？
* GMP 是什么？
* Go 中的内存逃逸现象是什么？

#### 并发相关
* 讲一下 channel，以及无缓冲 channel 和 有缓冲 channel 有什么区别？
* Go 语言中的 Channel 是什么, 有哪些用途，如何处理阻塞？
* map 是并发安全的吗，如何实现并发安全？
* 讲讲 GMP 模型调度器？
* go 语言中的线程池参数和怎么配置线程数？
* 如果让你设计 go 里面的锁，应该怎么设计？
* go 语言的并发模型是什么？
* go 的运行时是什么？
* 如何控制 go routine 的生命周期？
* Go什么时候发生阻塞？阻塞时调度器会怎么做？
* 切片是并发安全的吗？

#### 切片相关
* 了解切片吗？
* 切片和数组的区别是什么？
* 切片底层的数据结构是什么？有什么特性？
* 切片是如何扩容的？

#### Web 框架
* 你有使用过哪些 Go 的 Web 框架？介绍一下它们？
* 说一下 Gin 的拦截器的原理？
* Gin 的路由是怎么实现的？
* 介绍一下 Go 中的 context 包的作用？

#### defer 相关
* defer 是用来干嘛的以及 defer 的执行顺序是什么？

## 语言基础
#### 和 C++ 对比介绍一下 Go 语言的特点和优势？

和 C++ 相比的话 Go 最大的特点和优势自然就是语法的简洁了，比如写并发，go 自带协程和 channel，写法更直观也更简单，而 c++ 要用线程和锁自定义来写；另外像是内存管理和部署方面，go 的垃圾回收和天生的跨平台编译与容器化都很方便，不需要手动管理内存，一条命令就可以产出可执行文件，并且 go 还自带了性能分析等工具；同时 go 的性能与 c++ 也非常接近，工程效率却更高，更适合上层的常见后端应用开发

#### go 包管理的方式有哪些？

现在的主流是使用 Go Modules，是官方推荐的包管理工具，使用 go.mod 和 go.sum 来管理包和版本，不依赖 GOPATH，可以在任何地方创建项目

早期的话是 GOPATH 和 vendor，前者是没有版本锁定，所有项目都要放在 GOPATH 下面，后者是体积较大，升级也很麻烦，因为是把依赖的源码拷过去

#### go 支持重载吗？如何在 go 中实现一个方法的重载？

go 语言不支持重载，函数、方法、运算符的重载均不支持，在同一作用域里，不能定义多个名字相同参数不同的函数，但可以通过使用接口+类型断言，或者使用泛型来模拟重载，比较推荐使用泛型，因为它是类型安全的，并且有编译时检查

#### go 语言中如何实现继承？

go 语言是没有传统的继承方式的，但可以用结构体嵌入和接口来模拟，go 本身也是更提倡优先使用组合而非继承

比如结构体可以将另一个结构体嵌套为自己的字段，被嵌套的结构体中的匿名字段和方法会被提升到外部结构体中，可以直接访问和调用；子结构体可以定义与父结构体相同的方法，从而覆盖嵌套结构体的方法，实现类似方法重写的功能，如果需要调用被覆盖的方法，可以显式调用嵌套结构体的方法

go 的接口配合组合机制，就可以实现类似继承的多态功能，会调用自己类型的函数，但 go 并不支持访问控制，类似于 protected 这种关键字，所有嵌套字段和方法的访问权限取决于其首字母是否大写，同时也没有强制的父子关系和多级继承

#### go 语言中如何实现多态？

go 的多态主要有两种，接口多态和泛型多态，前者是运行时，后者是编译时；多态是指统一接口可以在不同类型上表现出不同的行为

接口多态是先定义接口，任何类型只要实现了接口要求的方法，就能被当成这个接口来用，用接口类型接收具体实现，调用时按实际类型派发

泛型多态则是给函数或类型加类型参数，再用约束限定可用操作，一个实现适配多种元素类型，在编译器实例化

接口多态本身是可以动态存储实现该接口的任何类型的，另外 go 还提供了类型断言和类型选择来识别不同类型，也可以让断言和选择来配合空接口实现泛型化的多态

#### map 和 slice 作为参数传递时会遇到什么问题？



#### Go 语言中 struct 和 class 有什么区别？



#### 讲讲 go 的错误处理机制？



#### 讲讲 go 里面常见的数据类型？



#### 在你日常使用 go 语言开发时有什么注意事项或者遇到过哪些问题吗？



#### 在 go 语言中什么时候会需要性能调优？



## 垃圾回收
#### new 和 make 的区别是什么？

A：new 和 make 都是申请内存，但它们各自针对不同场景，new 是给任意类型分配一块零值内存，返回的是该类型的指针，并不会做进一步的初始化，底层的引用类型仍然是 nil；而 make 是专门用于 slice、map 和 channel 这三种引用类型，返回的是初始化后的引用类型本身，底层的引用类型不再是 nil，如果用 new 来创建这三种类型，只会得到指向 nil 的指针，后续操作会出现运行时错误

#### 讲讲 GC 垃圾回收和内存逃逸

A：Go 的 GC 采用并发三色标记‑清扫，结合写屏障保证 mark 阶段不漏标，再通过分片清扫缩短停顿时间；可以通过调整 GOGC 来平衡内存使用和 CPU 开销。编译器会对每个变量做逃逸分析，判断它是在栈上分配还是堆上分配：凡是其生命周期超出当前函数栈帧，或作为接口／闭包／goroutine 参数存活更久，就会 ‘escapes to heap’。我们可以用 go build -gcflags='-m' 查看逃逸情况，在性能热点中避免不必要的堆分配，比如用值类型或对象池来减少 GC 压力

#### go routine什么情况会发生内存泄漏？如何避免？
#### 常见的 GC 实现方式有哪些？
#### Go 垃圾回收（GC）的触发条件是什么？
#### Go语言中的 GC 流程？
#### go 的垃圾回收机制了解吗？
#### GC 如何调优？
#### GMP 是什么？
#### Go 中的内存逃逸现象是什么？

## 并发相关
#### 讲一下 channel，以及无缓冲 channel 和 有缓冲 channel 有什么区别

A：channel 是 Go 语言中用于 goroutine 之间通信和同步的机制，类似于管道，可以在不同的 goroutine 之间传递数据，它替代了共享内存，通过通信来共享内存，让并发更安全更容易理解；无缓冲 channel 是指在发送数据时，发送方和接收方必须同时存在，才能完成数据的传递；而有缓冲 channel 则允许在发送数据时不需要接收方同时存在，发送方可以先将数据放入缓冲区中，接收方可以稍后再来接收数据；无缓冲 channel 更加严格，但也更容易出现死锁，而有缓冲 channel 则更加灵活，但也可能导致数据丢失或不一致的问题；在实际开发中，比如我有一个日志模块收集 goroutine，如果用无缓冲 channel，那么每条日志都要等后端写库确认后发送才能继续，会严重拖慢主流程，如果用有缓冲 channel，主流程只需要把日志推送缓冲就可以马上返回，大部分日志写入都在后台异步完成，保证了不会丢日志的同时也提高了并发吞吐量

#### Go 语言中的 Channel 是什么, 有哪些用途，如何处理阻塞？

#### map 是并发安全的吗，如何实现并发安全

A：Go 自身内置的 map 并不是并发安全的，多个 goroutine 如果同时写会触发 panic，如果想要用并发安全的 map，可以使用标准库的 sync.map，或者自己用 sync 的互斥锁读写锁写一套并发安全的 map，或者还有一些第三方的并发 map 库也可以用

#### Q：讲讲 GMP 模型调度器

A：GMP 是 go 语言中实现 M 比 N 调度的模型，G 是指 goroutine，M 是指 machine，也就是真正的操作系统线程，P 是指 processor，是运行时的调度令牌，数量由 GOMAXPROCS 这个参数控制；每个 P 会管理一个本地就绪队列，空闲的 M 拿到 P 之后就会去执行队列里的 G，当本地队列空了 P 就会从全局队列或其他 P 的队列窃取 G，go 语言通过写屏障还实现了抢占，确保长时间运行的 G 会释放 P，让其他的 G 也有机会跑，在系统调用时 M 会临时脱离 P 去调用内核，运行时再为 P 分配新的 M，让 go 代码不被阻塞，整个模型既保证了高并发，又能充分利用多核，非常适合网络和 IO 密集场景

#### go 语言中的线程池参数和怎么配置线程数

A：go 语言里其实没有显式的线程池概念，go 主要是用 GMP 实现的高并发，然后使用 GOMAXPROCS 这个参数来控制操作系统的线程数，默认值是机器的 CPU 核心数，如果想要控制任务并发度，可以在 goroutine 之上自己实现一个 worker pool，用一个缓冲 channel 作为信号量，或用一些比较成熟的第三方库，来限制同时启用的 goroutine 数量

#### 如果让你设计 go 里面的锁，应该怎么设计

A：嗯我会仿照 sync.Mutex 设计一个轻量级、原子性强且调度友好的结构，我会用一个原子整型表示锁状态，先用 CAS 尝试加锁，失败就把 goroutine 放入等待队列并 park，解锁时再把锁状态清零，唤醒队列中下一个 goroutine；我也会加入短时间自选、队列唤醒顺序控制，以及调试时的死锁检测功能，因为 goroutine 是由运行时调度的，不能用操作系统级的锁做阻塞，所以锁必须尽可能用户态完成调度，减少内核切换

#### go 语言的并发模型是什么？
#### go 的运行时是什么？
#### 如何控制 go routine 的生命周期？
#### Go什么时候发生阻塞？阻塞时调度器会怎么做？
#### 切片是并发安全的吗？



## 切片相关
#### 了解切片吗

A：切片是 Go 语言中一种动态数组的抽象，它是对数组的封装，提供了更灵活和方便的操作方式；切片由三部分组成：指向底层数组的指针、切片的长度和切片的容量；切片可以动态增长和缩小，支持对元素的增删改查等操作；切片在内存中是连续存储的，但它本身并不存储数据，而是引用底层数组的数据，它是对底层数组的动态视图；切片可以通过内置函数 make 来创建，也可以通过字面量来创建，比如 `s := []int{1, 2, 3}`；切片还支持切片操作，比如 `s[1:3]` 表示从索引 1 到索引 3 的子切片

#### 切片和数组的区别是什么？



#### 切片底层的数据结构是什么？有什么特性？



#### 切片是如何扩容的？



## Web 框架
#### 你有使用过哪些 Go 的 Web 框架？介绍一下它们？



#### 说一下 Gin 的拦截器的原理？



#### Gin 的路由是怎么实现的？



#### 介绍一下 Go 中的 context 包的作用？



## defer 相关
#### defer 是用来干嘛的以及 defer的执行顺序是什么

A：defer 主要是用来延迟执行的，常用于资源释放和清理操作，比如关闭文件、解锁和关闭事务等，它能保证在函数所有逻辑结束后，defer 的所有语句都被执行，可以增强代码的可读性和健壮性；defer 是在函数真正返回之前被执行的，多个 defer 会被压入一个栈，最后注册的最先执行，也就是先进后出，并且 defer 的参数在注册时就会被求值，也就是如果参数在中间有改变的话也不会影响 defer 的值