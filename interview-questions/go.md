## 问题列表
* new 和 make 的区别是什么？
* 讲讲 GC 垃圾回收和内存逃逸
* 讲一下 channel，以及无缓冲 channel 和 有缓冲 channel 有什么区别
* map 是并发安全的吗，如何实现并发安全
* 讲讲 GMP 模型调度器
* go 语言中的线程池参数和怎么配置线程数
* defer 是用来干嘛的以及 defer的执行顺序是什么
* 了解切片吗

## 内存相关
**Q：new 和 make 的区别是什么？**

A：new 和 make都是申请内存，但它们各自针对不同场景，new 是给任意类型分配一块零值内存，返回的是该类型的指针，并不会做进一步的初始化，底层的引用类型仍然是 nil；而 make 是专门用于 slice、map 和 channel 这三种引用类型，返回的是初始化后的引用类型本身，底层的引用类型不再是 nil，如果用 new 来创建这三种类型，只会得到指向 nil 的指针，后续操作会出现运行时错误

**Q：讲讲 GC 垃圾回收和内存逃逸**

A：Go 的 GC 采用并发三色标记‑清扫，结合写屏障保证 mark 阶段不漏标，再通过分片清扫缩短停顿时间；可以通过调整 GOGC 来平衡内存使用和 CPU 开销。编译器会对每个变量做逃逸分析，判断它是在栈上分配还是堆上分配：凡是其生命周期超出当前函数栈帧，或作为接口／闭包／goroutine 参数存活更久，就会 ‘escapes to heap’。我们可以用 go build -gcflags='-m' 查看逃逸情况，在性能热点中避免不必要的堆分配，比如用值类型或对象池来减少 GC 压力

## 并发相关
**Q：讲一下 channel，以及无缓冲 channel 和 有缓冲 channel 有什么区别**

A：channel 是 Go 语言中用于 goroutine 之间通信和同步的机制，类似于管道，可以在不同的 goroutine 之间传递数据，它替代了共享内存，通过通信来共享内存，让并发更安全更容易理解；无缓冲 channel 是指在发送数据时，发送方和接收方必须同时存在，才能完成数据的传递；而有缓冲 channel 则允许在发送数据时不需要接收方同时存在，发送方可以先将数据放入缓冲区中，接收方可以稍后再来接收数据；无缓冲 channel 更加严格，但也更容易出现死锁，而有缓冲 channel 则更加灵活，但也可能导致数据丢失或不一致的问题；在实际开发中，比如我有一个日志模块收集 goroutine，如果用无缓冲 channel，那么每条日志都要等后端写库确认后发送才能继续，会严重拖慢主流程，如果用有缓冲 channel，主流程只需要把日志推送缓冲就可以马上返回，大部分日志写入都在后台异步完成，保证了不会丢日志的同时也提高了并发吞吐量

**Q：map 是并发安全的吗，如何实现并发安全**

A：Go 自身内置的 map 并不是并发安全的，多个 goroutine 如果同时写会触发 panic，如果想要用并发安全的 map，可以使用标准库的 sync.map，或者自己用 sync 的互斥锁读写锁写一套并发安全的 map，或者还有一些第三方的并发 map 库也可以用

**Q：讲讲 GMP 模型调度器**

A：GMP 是 go 语言中实现 M 比 N 调度的模型，G 是指 goroutine，M 是指 machine，也就是真正的操作系统线程，P 是指 processor，是运行时的调度令牌，数量由 GOMAXPROCS 这个参数控制；每个 P 会管理一个本地就绪队列，空闲的 M 拿到 P 之后就会去执行队列里的 G，当本地队列空了 P 就会从全局队列或其他 P 的队列窃取 G，go 语言通过写屏障还实现了抢占，确保长时间运行的 G 会释放 P，让其他的 G 也有机会跑，在系统调用时 M 会临时脱离 P 去调用内核，运行时再为 P 分配新的 M，让 go 代码不被阻塞，整个模型既保证了高并发，又能充分利用多核，非常适合网络和 IO 密集场景

**Q：go 语言中的线程池参数和怎么配置线程数**

A：go 语言里其实没有显式的线程池概念，go 主要是用 GMP 实现的高并发，然后使用 GOMAXPROCS 这个参数来控制操作系统的线程数，默认值是机器的 CPU 核心数，如果想要控制任务并发度，可以在 goroutine 之上自己实现一个 worker pool，用一个缓冲 channel 作为信号量，或用一些比较成熟的第三方库，来限制同时启用的 goroutine 数量

## defer 相关
**Q：defer 是用来干嘛的以及 defer的执行顺序是什么**

A：defer 主要是用来延迟执行的，常用于资源释放和清理操作，比如关闭文件、解锁和关闭事务等，它能保证在函数所有逻辑结束后，defer 的所有语句都被执行，可以增强代码的可读性和健壮性；defer 是在函数真正返回之前被执行的，多个 defer 会被压入一个栈，最后注册的最先执行，也就是先进后出，并且 defer 的参数在注册时就会被求值，也就是如果参数在中间有改变的话也不会影响 defer 的值

## 切片相关
**Q：了解切片吗**

A：切片是 Go 语言中一种动态数组的抽象，它是对数组的封装，提供了更灵活和方便的操作方式；切片由三部分组成：指向底层数组的指针、切片的长度和切片的容量；切片可以动态增长和缩小，支持对元素的增删改查等操作；切片在内存中是连续存储的，但它本身并不存储数据，而是引用底层数组的数据，它是对底层数组的动态视图；切片可以通过内置函数 make 来创建，也可以通过字面量来创建，比如 `s := []int{1, 2, 3}`；切片还支持切片操作，比如 `s[1:3]` 表示从索引 1 到索引 3 的子切片