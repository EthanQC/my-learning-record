## 问题列表
* 介绍一下你的项目
* 项目做了哪些功能
* 挑一个你开发的功能模块介绍
* 为什么要做这个项目？项目规模多大？做之前有调研过其他同类产品吗？
* 你觉得你的项目相比别人有什么优点？
* 如果要优化你的项目，可能会有哪些可以优化的点？
* 回顾整个项目，你最自豪的技术实现点是什么？
* 如果给你一次重构机会，你最想改进或重写哪部分？为什么？
* 分析一下你之前项目当中，印象比较深刻的部分（难点，亮点）

#### 后端项目
* 项目的高并发是怎么做的？是自己假想了高并发的场景？
* 项目的同步机制和低延迟通信是怎么做的？
* 项目里有没有使用过多线程，线程安全问题
* 为什么项目要用微服务
* JWT 令牌支持单设备和多设备登录控制是怎么做的？
* 是如何具体用JWT实现身份认证的？
* （如果简历里有写压测）10w+ 并发用户是怎么测的，用什么工具？
* （如果简历里有写部署）项目服务器是怎么部署的？用到了几台服务器？
* 项目为什么要用 JWT

##### 微服务架构设计
* 请详细描述你是如何拆分各个子服务（用户管理、游戏逻辑、通信模块等）的？
* 服务之间如何注册与发现？通信用的是什么协议、如何组织调用链路？

##### RESTful API 与 Gin
* 你在设计 RESTful 接口时遵循了哪些规范？如何处理版本控制和向后兼容？
* 在 Gin 中你做了哪些性能优化（中间件、路由分组、Context 池化等）？

##### 身份认证与安全（JWT）
* JWT 的签发、验证、刷新流程是怎样的？
* 如何防范令牌被篡改、重放攻击和泄露？
* 如果用户登出或被强制下线，你如何实现令牌的即时失效？

##### 游戏逻辑与实时通信（WebSocket）
* 在一对四联机对战场景下，你如何设计房间管理和玩家状态同步？
* WebSocket 连接的生命周期如何管理？断线重连、心跳检测是怎么实现的？

##### 数据存储与一致性
* 核心数据表（如用户表、游戏进度表）的字段设计和索引策略是什么？请给出示例 DDL。
* Redis 缓存与 MySQL 主库之间如何保证强一致或最终一致？遇到缓存雪崩/穿透/击穿如何应对？

##### ORM 使用（GORM）
* GORM 在你的项目中带来了哪些便利？也请指出它的瓶颈与坑，你是如何规避或优化的？
* 如何避免 N+1 查询、事务死锁，如何优雅地执行批量插入/更新？

##### 高并发与性能调优
* 你的系统在高并发情况下的最大吞吐量和延迟是多少？使用了哪些压测工具和指标？
* 在 Go 运行时层面，你做过哪些 goroutine 调度或 GC 调优？能举一个具体案例并说明效果吗？

##### 缓存与消息队列
* 除了 Redis，你是否考虑过使用消息队列来解耦或削峰？为什么最终没有选用？
* 如果要引入如 Kafka 或 RabbitMQ，你会怎么设计？

##### 错误处理与容错
* 服务调用链路中如何实现超时、重试、限流、熔断？
* 遇到部分节点故障时，系统如何保证可用性和数据安全？

##### 测试与质量保障
* 单元测试、集成测试、端到端测试分别是如何组织的？覆盖率是多少？
* 你在项目中用过哪些测试框架（Go Testing、Testify），请分享一个你最满意的测试用例。

##### 持续集成与部署
* 请描述一下从代码提交到线上部署的完整流水线（CI/CD）。
* 如何做灰度发布、滚动升级与回滚？如果新版本导致线上崩溃，你会如何快速恢复？

##### 监控与报警
* 上线后你引入了哪些监控指标（QPS、P99 延迟、错误率等）？使用了哪些监控系统和可视化面板？
* 某天凌晨突发错误率上升，你的排查思路和具体操作步骤是什么？

##### 横向扩展与容量规划
* 如果用户规模达到百万级，你会在集群、数据库、缓存和网络层面做哪些优化和扩容？
* 请结合成本与运维复杂度，给出一份可行的横向扩展方案。

##### 安全与合规
* 在日志中你会记录哪些敏感信息？如何保证日志安全与隐私合规？
* 如果要对接第三方支付/实名制/防沉迷系统，你会如何接入并保证安全性？

## 后端项目
**Q：介绍一下你的项目**

A：这个项目是我为我的独立游戏《月华》的联机版独立开发的后端服务器，整体是用 Go 语言的 Gin 框架和微服务架构实现的，目前主要实现了玩家的注册登录、身份认证、对战房间和卡牌核心逻辑以及实时同步的开发，我是使用 Gin 构建了 RESTful API 来和前端服务通信，通过 JWT 做身份校验，然后用 GORM 和 MySQL 来持久化玩家与进度数据，还使用 Redis 缓存热点数据，状态同步方面主要是用 websocket 来实现长连接的推送帧数据与事件，但像竞速和队列匹配模块目前是还在实现中

**Q：项目的高并发是怎么做的？是自己假想了高并发的场景？**

A：嗯目前项目只是在本地测试过，使用了 Go 的 goroutine 来处理并发请求，主要是通过事件循环避免多线程竞争和 Worker Pool 来限制并发数量，避免过多的协程导致内存溢出和 CPU 占用过高。还有就是使用了 Redis 来缓存热点数据，减少数据库的压力并实现分布式一致性，就是跨示例共享快照。再就是用 GORM 的一些配置做动态扩缩容，然后非关键路径的数据可以异步写入；高并发场景主要是考虑到游戏上线后可能会有大量玩家同时在线，所以我在设计时就考虑到了这一点；我是预计在项目的各个模块都比较完善之后再开始压测，使用一些开源的压测工具来模拟高并发场景

**Q：项目的同步机制和低延迟通信是怎么做的？**

A：同步机制的话我使用的是状态同步，服务器以事件驱动的方式先执行所有游戏逻辑，然后把结果通过 websocket 下发广播给所有客户端，客户端直接应用这些更新并渲染界面，为了兼顾丢包或重连场景我还用 redis 做了定时快照，客户端断线重连时可以拉取最新快照并应用，同时因为是卡牌游戏，所以没有使用帧同步就是对于延迟和实时性零容忍的同步机制，状态同步就是容错性会更强一些，开发和调试成本也会低一些；低延迟通信的话我是用 websocket 和 protobuf 实现的，主要是用了常见的比如长连接和心跳检测机制，然后结合状态同步机制，实现的低延迟通信

**Q：项目里有没有使用过多线程，线程安全问题**

A：嗯这个项目的话因为是用 go 写的嘛，所以用的其实都是 goroutine 和 channel，并没有直接操作操作系统的线程调度，而是用调度器也就是 GMP 来把多个轻量级 goroutine 调度到多个线程上来降低线程上下文切换和栈内存的开销，然后必要时会使用互斥锁或者用原子操作来保证线程安全；因为我自己最开始学的是 C++，所以我是在一些 C++ 的项目中有用它的标准库操作过多线程和互斥锁的，像是 std::thread 和 std::mutex 这些；在这个项目中我没有使用过多线程，因为 Go 的 goroutine 和 channel 已经足够满足我的需求了

**Q：为什么项目要用微服务**

A：其实最主要的好处就是能够把项目拆分成多个小的服务，方便开发和维护；还有就是可以根据业务需求来选择不同的技术栈，比如我在这个项目中用的是 Go 语言的 Gin 框架来做后端服务，然后准备用 C++ 来编写一些要求高性能计算的模块，这就很方便；还有就是微服务架构能更好地支持高并发和高可用性，因为每个服务都是独立的，可以根据负载情况来动态扩缩容某一个具体的模块，避免单点故障，然后想要修改某个模块时也可以单独重构而不是重做整个项目，这样迭代也会更快一些

**Q：JWT 令牌支持单设备和多设备登录控制是怎么做的？**

A：

**Q：是如何具体用JWT实现身份认证的？**

A：用户注册后会先登录，登陆时调用登录接口，然后拉取用户的密码哈希并校验，如果校验成功就会生成一个 JWT 令牌，令牌里会包含用户的 ID 和过期时间等信息，然后把这个令牌返回给客户端，客户端在后续的对受保护的接口的请求中会把这个令牌放在请求头里，服务器端通过中间件拦截所有受保护路由，会验证这个令牌的合法性和过期时间，如果合法就可以通过身份认证了；JWT 的好处就是无状态的，不需要在服务器端存储任何会话信息，只需要验证签名就可以了，这样就能更好地支持分布式架构和负载均衡了

**Q：项目为什么要用 JWT**

A：JWT 可以让服务端不用存储会话状态，验证只靠解析和验证签名，无论请求落到哪台后端都能独立鉴权，对高并发、微服务和云原生场景比较友好，同时 JWT 也支持跨域和移动端支持，能复用同样的鉴权逻辑，也可以携带自定义的一些声明比如角色、权限、过期时间等，这样服务器中间件只需要解析一次就能拿到玩家的多个信息，无需二次查库，另外 JWT 也能实现安全性和过期控制，既轻量化又可控