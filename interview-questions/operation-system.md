## 问题列表
#### 进程与线程
* 进程和线程的区别是什么？
* 线程、协程和 goroutine 之间的区别
* 为什么 CPU 密集用多进程，IO 密集用多线程

#### 锁
* 如果续锁失败了怎么办

#### 内存与磁盘
* Cache 是什么，它具体是怎么工作的，怎么跟内存合作？
* 既然提到了内存，你知道虚拟内存吗？
* 既然提到了磁盘，内存和磁盘是怎么合作的？若内存中没找到数据会怎么样？

#### 系统调度
* 打开一个程序会发生什么
* 电脑参数常说的几核几线程是什么意思，常说的电脑是多少核，真的会有这么多核吗

#### Linux
* 你具体在什么项目里用到了 epoll？你是如何编写事件循环、处理 socket 可读写事件的？
* epoll 的 LT（Level Trigger）和 ET（Edge Trigger）模式有何区别？在高并发服务器里为什么更倾向用 ET 模式？
* 如何避免 epoll 中的惊群效应？
* 你对 Linux 内核中进程、线程、文件描述符这些概念，能否简要解释一下它们的关系，以及底层是如何管理资源的？

#### 游戏开发
* 有了解过游戏开发中的多线程吗？
* 游戏开发中多线程的应用场景会有哪些？

## 进程与线程
**Q：进程和线程的区别是什么？**

**A（自己回答）：** 进程是由操作系统调度的，每个进程有自己的内存地址和占用资源，线程是在进程内创建的，一个进程内可以有多个线程，多个线程之间共享进程的内存地址，但也有自己独有的资源占用

**A（标答）：**

（**要点总结**：）

进程拥有独立地址空间，线程共享所属进程内存；进程切换需切换虚拟地址空间，开销大；线程切换仅切换寄存器和栈，开销小；线程间共享内存，高效；进程间需借助 IPC，复杂且成本高

（**原理分析**：）
进程是操作系统分配资源的基本单位，拥有独立的内存页表、文件描述符和内核数据结构；线程是进程内的执行流，同进程共享堆和全局变量，但拥有独立的栈和寄存器上下文。进程上下文切换涉及地址空间切换与内核态切换，性能损耗较大；线程上下文切换仅切换少量寄存器，性能更优

（**业务场景示例**：）
在高并发 Web 服务中，Nginx 采用多进程模型隔离请求，保证稳定性和安全；而 Go/C++ 应用服务器大多框架使用 Reactor 模型，通过线程池处理请求，利用线程共享内存快速调度，提高吞吐量并降低上下文切换成本

**Q：线程、协程和 goroutine 之间的区别**

A：

特性 | 线程（Thread） | 协程（Coroutine） | Goroutine
级别 | 操作系统级（OS thread） | 用户态（User‑level） | Go 运行时级
调度 | 由操作系统内核抢占式调度 | 协作式调度，需要程序员显式 yield／await | Go 运行时调度器预emptive（安全点抢占）
映射模型 | 一对一（1 OS thread = 1 kernel thread） | 通常一对一或手工 M:N（depends on 实现） | M:N：数万 Goroutine 映射到少量 OS 线程上

二、资源开销与栈管理
线程

栈大小：固定（通常 1–2 MB），上下文切换成本高。

创建销毁：系统调用，耗时几十到几百微秒。

并行性：真正并行，可利用多核，适合 CPU 密集型任务。

协程

栈大小：多为固定或可伸缩，视语言实现而定（如 Lua 协程固定栈，Python asyncio 无真实栈切换）。

切换开销：非常轻量，通常在几百纳秒级别，但需要显式让出（yield、await）。

并行性：通常在单 OS 线程内协作式切换，不能自动负载到多核。

Goroutine

栈大小：动态伸缩，初始仅几 KB，根据需要增长／收缩，节省内存。

切换开销：Go 运行时自己管理调度，切换成本低（几十微秒以内），且自动在安全点抢占。

并行性：借助 GOMAXPROCS 把多个 Goroutine 映射到多个 OS 线程上并行执行，兼顾轻量与多核利用。

三、编程模型与使用体验
线程编程

常见于 Java/C++：使用 std::thread、Thread 类，需自己管理锁、条件变量和竞争风险。

优点：真正并行；缺点：线程池、锁、死锁、竞态条件复杂，写法繁琐。

协程编程

典型如 Python asyncio、JavaScript async/await、Lua coroutine：需在异步框架里写 await 或 yield，否则不会切换。

优点：代码看上去像同步，易读；缺点：只能在框架内调度，不能自动并行全核。

Goroutine 编程

Go 只需 go f() 一行代码就能启动一个轻量任务，无需显式 yield。

调度器在后台负责抢占、负载均衡，开发者只管写并发逻辑，极大简化了并发编程的复杂度。

四、总结对比
线程：重量级、抢占式、真正并行、管理复杂。

协程：轻量级、用户态协作式、切换依赖程序逻辑、易读但不能自动并行。

Goroutine：更“高配”的协程，结合了轻量级动态栈、运行时预emptive 调度和 M:N 并行映射，既保留了协程编程简洁，又做到多核利用。

**Q：为什么 CPU 密集用多进程，IO 密集用多线程**

A：对于 CPU 密集型任务，我们希望每个执行单元都能跑在不同的核心上，任务主要消耗的是 CPU 的运算能力，为了充分利用多核，并避免全局锁竞争，因此常用多进程，每个进程拥有独立的内存空间，天然避免了线程之间的共享内存竞争和锁开销，切换成本在重计算场景下可忽略，还能做更稳健的故障隔离，一个进程崩溃不会直接带垮其他进程，在纯计算场景下调度器也不会频繁切换；对于 IO 密集型任务，线程更加轻量级，上下文切换快，且线程间共享内存便于数据交换，适合需要频繁在任务之间传递数据、聚合结果的场景，当一个线程因为 I/O 阻塞时，CPU 可以马上切换到其他线程，最大化利用空闲周期，在多数语言中用线程或 goroutine 就能轻松实现高并发 I/O 并且编程简单，在线程内部也可以再结合非阻塞 I/O 或 Reactor 模型，比如在 web 服务器里一个线程就可以同时管理上千个连接的读写，只有活跃时才消耗 CPU

## 锁


**Q：如果续锁失败了怎么办**

A：如果续锁失败，首先就是要立刻停止依赖该锁的后续逻辑，避免多个实例同时操作同一资源，捕获续锁失败的错误后返回给上层，让调用链立刻回滚或降级，然后要清理本地可能存在的一些准备好的上下文或预占用资源，比如关闭数据库事务、归还连接、删除临时文件等，业务操作要尽量设计成幂等，即使多次失败重试也不会出现重复或丢失，接着就是续锁失败要写入日志并触发告警，最后就是对业务逻辑数据做异步补偿，比如把未处理的玩家操作写入消息队列，后台再重试，然后借助有限次重试，在几次重试都失败后才彻底放弃，避免持续占用锁资源

## 内存与磁盘
**Q：Cache 是什么，它具体是怎么工作的，怎么跟内存合作？**

A：

**Q：既然提到了内存，你知道虚拟内存吗？**

A：

**Q：既然提到了磁盘，内存和磁盘是怎么合作的？若内存中没找到数据会怎么样？**

A：

## 系统调度
**Q：打开一个程序会发生什么**

A：首先内核会创建子进程，并为子进程查找并打开可执行文件，校验访问权限和文件完整性，然后内核会为子进程分配内存空间，加载可执行文件到内存中，并为其分配栈、堆和数据段等内存区域；接着内核会设置进程的状态、优先级和调度策略，然后将 CPU 的控制权转交给子进程，把 CPU 权限从内核态切回用户态，开始执行程序的入口函数；在执行过程中，内核会根据需要进行系统调用，处理 I/O 操作、内存管理和进程调度等任务；当程序执行完毕或遇到异常时，内核会清理资源并终止进程

**Q：电脑参数常说的几核几线程是什么意思，常说的电脑是多少核，真的会有这么多核吗**

A：常说的几核几线程是指 CPU 拥有的物理核心数和每个核心能同时处理的硬件线程数，比如一颗四核八线程的处理器就意味着它有四个物理核心，每个核心支持两条并发的执行线程，也就是支持超线程技术，多核可以提升并发处理能力，而多线程则提高了每个核心的利用率，尤其是在等待 IO、分支预测失误时更能保持吞吐，现在主流的笔记本一般是四核八线程或八核十六线程，高端一些的服务器甚至可以达到六十四核一二八线程，所以确实是会有这么多核，像在 go 里面调 GOMAXPROCS 这个参数实际上也是为了更好的调度核心

## Linux 
**Q：你具体在什么项目里用到了 epoll？你是如何编写事件循环、处理 socket 可读写事件的？**

A：

**Q：epoll 的 LT（Level Trigger）和 ET（Edge Trigger）模式有何区别？在高并发服务器里为什么更倾向用 ET 模式？**

A：

**Q：如何避免 epoll 中的惊群效应？**

A：

**Q：你对 Linux 内核中进程、线程、文件描述符这些概念，能否简要解释一下它们的关系，以及底层是如何管理资源的？**

A：

## 游戏开发
**Q：有了解过游戏开发中的多线程吗？**

A：

**Q：游戏开发中多线程的应用场景会有哪些？**

A：