## 垃圾回收
#### new 和 make 的区别是什么？

A：new 和 make 都是申请内存，但它们各自针对不同场景，new 是给任意类型分配一块零值内存，返回的是该类型的指针，并不会做进一步的初始化，底层的引用类型仍然是 nil；而 make 是专门用于 slice、map 和 channel 这三种引用类型，返回的是初始化后的引用类型本身，底层的引用类型不再是 nil，如果用 new 来创建这三种类型，只会得到指向 nil 的指针，后续操作会出现运行时错误

#### 讲讲 GC 垃圾回收和内存逃逸

A：Go 的 GC 采用并发三色标记‑清扫，结合写屏障保证 mark 阶段不漏标，再通过分片清扫缩短停顿时间；可以通过调整 GOGC 来平衡内存使用和 CPU 开销。编译器会对每个变量做逃逸分析，判断它是在栈上分配还是堆上分配：凡是其生命周期超出当前函数栈帧，或作为接口／闭包／goroutine 参数存活更久，就会 ‘escapes to heap’。我们可以用 go build -gcflags='-m' 查看逃逸情况，在性能热点中避免不必要的堆分配，比如用值类型或对象池来减少 GC 压力

#### go routine什么情况会发生内存泄漏？如何避免？



#### 常见的 GC 实现方式有哪些？



#### Go 垃圾回收（GC）的触发条件是什么？
#### Go语言中的 GC 流程？为什么 go 语言不需要自己的去申请内存？
#### go 的垃圾回收机制了解吗？
#### GC 如何调优？
#### GMP 是什么？
#### Go 中的内存逃逸现象是什么？
#### GC 主要回收的是堆还是栈？

那关于内存管理，比如说像 go 和 php 这种面向对象的高级语言，基本上内存你都不需要自己去申请，然后对应它会有垃圾回收，那为什么它不需要自己去申请内存，它是怎么做到的，以及它的垃圾回收是怎么结合的，可以用 go 来说

那其实你刚刚主要是介绍了一下它的垃圾回收，我刚刚前面的问题其实其中一问就是为什么不需要自己的去申请它的内存，它是怎么来结合这个垃圾回收的，因为是应该先有前面的才会有这个垃圾回收嘛，所以前面它是怎么做的，这部分能再补充一下吗？

所以垃圾回收主要回收的是堆的还是栈的？

我就是说 GC 部分就是垃圾回收部分主要回收的是堆还是栈，包括你刚刚的说的三色标记法，它标记的是全局对象还是调用栈