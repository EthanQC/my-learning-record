## 进程与线程
#### 进程和线程的区别是什么？

**A（自己回答）：** 进程是由操作系统调度的，每个进程有自己的内存地址和占用资源，线程是在进程内创建的，一个进程内可以有多个线程，多个线程之间共享进程的内存地址，但也有自己独有的资源占用

**A（标答）：**

（**要点总结**：）

进程拥有独立地址空间，线程共享所属进程内存；进程切换需切换虚拟地址空间，开销大；线程切换仅切换寄存器和栈，开销小；线程间共享内存，高效；进程间需借助 IPC，复杂且成本高

（**原理分析**：）
进程是操作系统分配资源的基本单位，拥有独立的内存页表、文件描述符和内核数据结构；线程是进程内的执行流，同进程共享堆和全局变量，但拥有独立的栈和寄存器上下文。进程上下文切换涉及地址空间切换与内核态切换，性能损耗较大；线程上下文切换仅切换少量寄存器，性能更优

（**业务场景示例**：）
在高并发 Web 服务中，Nginx 采用多进程模型隔离请求，保证稳定性和安全；而 Go/C++ 应用服务器大多框架使用 Reactor 模型，通过线程池处理请求，利用线程共享内存快速调度，提高吞吐量并降低上下文切换成本

#### 线程、协程和 goroutine 之间的区别



#### 为什么 CPU 密集用多进程，IO 密集用多线程

A：对于 CPU 密集型任务，我们希望每个执行单元都能跑在不同的核心上，任务主要消耗的是 CPU 的运算能力，为了充分利用多核，并避免全局锁竞争，因此常用多进程，每个进程拥有独立的内存空间，天然避免了线程之间的共享内存竞争和锁开销，切换成本在重计算场景下可忽略，还能做更稳健的故障隔离，一个进程崩溃不会直接带垮其他进程，在纯计算场景下调度器也不会频繁切换；对于 IO 密集型任务，线程更加轻量级，上下文切换快，且线程间共享内存便于数据交换，适合需要频繁在任务之间传递数据、聚合结果的场景，当一个线程因为 I/O 阻塞时，CPU 可以马上切换到其他线程，最大化利用空闲周期，在多数语言中用线程或 goroutine 就能轻松实现高并发 I/O 并且编程简单，在线程内部也可以再结合非阻塞 I/O 或 Reactor 模型，比如在 web 服务器里一个线程就可以同时管理上千个连接的读写，只有活跃时才消耗 CPU

#### 进程间的通信方式有哪些？（同台设备和不同台设备）

* 并行和并发的区别是什么？

* 为什么协程会出现，它的应用场景是什么？

* 那为什么会引入到协程呢？它是为了解决什么样的问题呢？

* 那你在哪一些场景下会更倾向于使用协程？除了所谓的 context 切换，因为这个问题在进程线程里都有，那你拿到一个任务，在什么场景下你会更愿意用协程来解决这个任务？

* 有了解过线程安全吗？能不能讲一下你在写代码时遇到过的一些问题，或者你先简单解释一下什么是线程安全



## 锁


**Q：如果续锁失败了怎么办**

A：如果续锁失败，首先就是要立刻停止依赖该锁的后续逻辑，避免多个实例同时操作同一资源，捕获续锁失败的错误后返回给上层，让调用链立刻回滚或降级，然后要清理本地可能存在的一些准备好的上下文或预占用资源，比如关闭数据库事务、归还连接、删除临时文件等，业务操作要尽量设计成幂等，即使多次失败重试也不会出现重复或丢失，接着就是续锁失败要写入日志并触发告警，最后就是对业务逻辑数据做异步补偿，比如把未处理的玩家操作写入消息队列，后台再重试，然后借助有限次重试，在几次重试都失败后才彻底放弃，避免持续占用锁资源

* 什么是互斥锁（mutex）？在什么情况下会用到它们？（联系 go 语言中的实际应用）

* 互斥锁有几种模式？有几种状态？