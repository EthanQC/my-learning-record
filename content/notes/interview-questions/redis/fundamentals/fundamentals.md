## 基础
#### 什么是 Redis？

Redis，Remote Dictionary Service，是一个开源的**键值对数据库服务器**，或者说是一个数据结构服务器，它不通过迭代或者排序方式处理数据，而是直接**按照数据结构的方式组织**

主要来说，它是一个**内存数据库**，被用作例如 **MySQL 前的缓存**，来提高应用程序的性能，它利用**内存的高速访问**来减轻核心应用程序数据库的负载，它的 QPS 跟 MySQL 相比也非常高，可以更好地应对**高并发场景**

**不经常更改但经常被请求**的数据，或者**任务关键性较低但经常更改**的数据，都可以存到 Redis 中

![how-is-redis-traditionally-used](how-is-redis-traditionally-used.png)

Redis 对数据的操作都是**原子性**的，它由单线程负责执行命令，**不存在并发竞争的问题**，还支持**事务、持久化、Lua 脚本、多种集群方案（主从复制、哨兵、切片集群）、发布/订阅模式、内存淘汰和过期删除机制**等功能

#### Redis 和 Memcached 有什么区别？

Redis 和 Memcached 都是基于**内存**的数据库，一般都用来当作缓存使用，它们都有过期策略，性能也都非常高

但 Redis **支持的数据类型更加丰富**，还支持**数据的持久化、原生集群和事务**等其他功能，Memcached 是没有持久化功能的，也没有原生的集群模式，更不支持其他功能

#### Redis 是单线程的吗？

Redis 单线程指的是，**接收客户端请求 - 解析请求 - 进行数据读写等操作 - 发送数据给客户端**，这个过程是由一个主线程来完成的，**Redis 程序并不是单线程的**，它在启动时会启动多个**后台线程（BIO）**

![redis-backend-process](redis-backend-process.png)

**关闭文件、AOF 刷盘和释放内存**这三个任务都有各自的任务队列，然后由后台线程去**异步**处理这些任务，从而避免阻塞主线程，提高 Redis 的性能

#### Redis 的单线程模型是什么样的？

Redis 在 6.0 版本之前采用的是单线程模型，所有的客户端请求都是由一个主线程来处理的，通过**I/O 多路复用技术**来同时监听多个客户端连接，当有客户端请求到达时，主线程会依次处理这些请求

![redis-single-process-model](redis-single-process-model.png)

Redis 在初始化时，会先调用 **`epoll_create()`** 和 **`socket()`** 来创建一个 epoll 对象和一个服务端 socket，然后调用 **`bind()`** 和 **`listen()`** 来绑定端口并监听客户端连接请求，再调用 **`epoll_ctl()`** 把服务端监听的 socket 添加到 epoll 对象中，同时注册**连接事件处理函数**

初始化之后，主线程就会进入到一个**事件循环函数**，先调用**处理发送队列函数**，来看发送队列里是否有任务，如果有发送任务，就通过 **`write()`** 函数将**客户端发送缓存区**里的数据发送出去，如果这一轮数据没有发送完，就会注册**写事件处理函数**，等待 **`epool_wait()`** 检测到 socket 可写时，再次调用**处理发送队列函数**来继续发送数据

然后会调用 **`epoll_wait()`** 来等待事件的到来，如果是**连接事件**，就会调用**连接事件处理函数**，它会调用 **`accept()`** 来获取已连接的 socket，然后调用 **`epoll_ctl()`** 把已连接的 socket 添加到 epoll 对象中，同时注册**读事件处理函数**

如果是**读事件**，就会调用**读事件处理函数**，它会调用 **`read()`** 函数来读取客户端发送过来的数据，然后进行命令解析和处理，最后把客户端对象添加到发送队列，将执行结果写到**发送缓存区**等待发送

如果是**写事件**，就会调用**写事件处理函数**，它会调用 **`write()`** 函数来发送客户端发送缓存区里的数据，如果这一轮数据没有发送完，就会继续注册**写事件处理函数**，等待 **`epoll_wait()`** 检测到 socket 可写时，再次调用**写事件处理函数**来继续发送数据

#### 为什么 Redis 采用的是单线程还能这么快？6.0 之前为什么要使用单线程？

单线程的 Redis 吞吐量可以达到 **10w QPS** 以上，主要的原因是 Redis 的大部分操作都在**内存中**完成，并且采用了**高效的数据结构**，**CPU 并不是制约 Redis 性能的瓶颈，机器的内存和网络带宽才是**

Redis 采用的单线程模型**避免了多线程之间的竞争**，节省了**多线程切换**带来的时间和性能上的开销，也避免了**死锁**问题，**I/O 多路复用机制**可以处理大量的客户端 socket 请求，一个线程可以处理多个 IO 流，也就是 **select/epoll** 机制，它**允许内核中存在多个监听 socket 和已连接 socket**，内核会一直监听这些 socket 上的连接请求或数据请求，一旦有请求到达，就会通知 Redis 线程处理，从而实现了**一个 redis 线程处理多个 IO 流的效果**

如果想要使用多核 CPU，可以在一台服务器上启动**多个 Redis 节点或采用分片集群**的方式，并且使用单线程的**可维护性也更高**，多线程模型虽然在某些方面表现优异，但它引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度，同时可能存在线程切换、加锁解锁和死锁造成性能损耗

#### Redis 6.0 之后为什么引入了多线程？

随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在**网络 I/O 的处理**上，所以在 6.0 之后 Redis 也采用了**多个 I/O 线程来处理网络请求**，但对于**命令的执行，Redis 仍然使用单线程来处理**

在默认情况下，Redis 支持的 I/O 多线程特性**只针对发送响应数据**，并不会以多线程的方式处理读请求，要开启多线程处理客户端读请求的话就需要把 **Redis.conf** 配置文件中的 **`io-threads-do-reads`** 选项设置为 **`yes`**，还可以通过 **`io-threads`** 选项来设置 I/O 线程的数量，如果是 4 核的 CPU 建议线程数设置为 2 或 3，8 核则建议设置为 6，线程数一定要小于机器核数，线程数并不是越大越好的

所以在 6.0 版本之后，Redis 启动时在默认情况下，除了主线程以外，会**额外创建 6 个线程**，加起来一共是：

* **Redis-server**
  * **主线程**，主要负责执行命令
* **BIO 线程**，主要负责**异步**处理**后台任务**
  * bin_close_file
    * 关闭文件
  * bin_aof_fsync
    * AOF 刷盘
  * bio_lazy_free
    * 释放内存
* **I/O 线程**，主要负责处理**网络请求**
  * io_thd_1
  * io_thd_2
  * io_thd_3
  * io-threads 默认是 4，所以会启动 4 - 1 = 3 个 I/O 多线程来分担 Redis 网络 I/O 的压力

#### Redis 是如何实现数据不丢失的？

