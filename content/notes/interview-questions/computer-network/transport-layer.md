## 基本概念
#### 什么是 TCP？

TCP 是**面向连接的、可靠的、基于字节流的**传输层通信协议

面向连接是指一定得是一对一才能连接，一对多是无法做到的

可靠是指无论网络链路中出现了什么变化，TCP 都可以保证一个报文一定能够到达接收端

基于字节流是指当消息通过 TCP 传输时，消息可能会被分成多个 TCP 报文，如果接收方不知道**消息边界**，是无法读出有效的消息的，并且 TCP 报文是有序的，当前一个报文没有收到时，即使后面的报文先收到了，也不能直接给应用层去处理，另外对于重复的报文 TCP 会自动丢弃

#### 如何唯一确定一个 TCP 连接？

一个 TCP 连接是由唯一的一个**四元组**所确定的，包括**源地址、源端口、目标地址和目标端口**

其中源地址和目标地址的字段是在 IP 头部中，是通过 IP 协议发送报文给对方主机

源端口和目标端口则是在 TCP 头部中，是告诉 TCP 协议应该把报文发给哪个进程

#### 有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？

理论上最大的连接数是**客户端的 IP 数 * 客户端的端口数**，但服务端最大 TCP 并发连接数是达不到理论上限的

由于每个 TCP 连接都是一个文件，Linux 对可以打开的文件描述符数量分别做了系统级、用户级和进程级的限制，另外每个 TCP 连接也会占用一定内存，而操作系统的内存是有限的

#### 你知道 TCP 和 UDP 吗？它们的区别是什么？分别的应用场景是？

TCP 是**面向连接的、可靠的、基于字节流的**传输协议，它保证数据完整有序到达，而 UDP 是**无连接的不可靠传输协议**，它延迟极低，注重传输速度和简单性

区别则在于**连接方式、可靠性、传输顺序、传输速度、头部开销、流量控制和拥塞控制**

TCP 需要先通过三次握手建立连接（SYN、SYN-ACK、ACK），数据传输完成后还要通过四次挥手释放连接（FIN、ACK、FIN-ACK、ACK），且连接只能一对一，而 UDP 则是直接发送数据包，不需要握手和挥手，还可以**一对多或者多对多**

TCP 通过确认应答、超时重传和校验和来确保数据可靠，UDP 是没有重传机制的，发送即丢弃，可靠性由应用层处理

TCP 通过序列号来保证接收端能按序重组数据，并且是基于字节流的，传输的数据都是二进制的无边界字节串，UDP 不维护数据顺序，接收端可能乱序接收，且是面向报文的，传输的都是有边界的应用层的报文包

TCP 如果数据的大小太大会在传输层进行分片，接收端也是在传输层组装，而 UDP 则是在 IP 层进行分配和组装

TCP 因连接管理、流量控制和重传等机制，传输延迟是比较高的，UDP 没有相应的开销，所以传输速度极快

TCP 的头部最小 20 字节，包含序列号、确认应答号、窗口大小和控制位（ACK、RST——连接出现异常要强制断开、SYN、FIN）等字段，还有可选字段能扩展，UDP 的头部则是**固定** 8 个字节，仅含源端口、目标端口、包长度和校验和（防止收到在网络传输中受损的数据包）

TCP 能通过滑动窗口动态调整发送速率，避免接收方缓冲区溢出，UDP 则无流量控制，可能会因为接收方处理不及时而导致丢包

TCP 通过慢启动、拥塞避免和快速重传等算法来避免网络拥堵，UDP 无拥塞控制，反而可能加剧拥塞

TCP 的应用场景主要在于 HTTP、HTTPS、邮件和文件传输，而 UDP 的则是 DNS 查询、视频音频和在线游戏

#### TCP 和 UDP 可以使用同一个端口吗？

可以，TCP 和 UDP 各自的端口号是**互相独立**的

链路层使用 MAC 地址找到局域网的主机后，网络层使用 IP 地址来寻址网络中互联的主机或路由器，传输层是用端口来寻址，识别统一计算机中同时通信的不同应用

而 TCP 和 UDP 在内核中是两个完全独立的软件模块，当主机收到数据包后可以通过 IP 包头的协议号知道该数据包是 TCP 还是 UDP，从而分配给对应的模块处理，模块处理完报文再根据端口号确定给哪个 TCP 应用还是给 UDP 应用

## TCP 连接
#### TCP 三次握手过程是什么样的？

一开始客户端和服务端都处于 CLOSE 状态，然后服务端会主动监听某个端口，处于 LISTEN 状态

接下来**客户端**会随机初始化序列号 client-isn，并把 SYN 置于 1，表示 SYN 报文，再把这**第一个 SYN 报文**发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，然后客户端处于 SYN-SENT 状态

**服务端**在收到客户端的 SYN 报文后，会先随机初始化自己的序列号 server-isn，再把自己的确认应答号填入 client-isn + 1，再把 SYN 和 ACK 都置 1，再把这**第二个 SYN-ACK 报文**发给客户端，该报文也不含应用层数据，然后服务端处于 SYN-RCVD 状态

**客户端**在收到服务端的报文之后，会再回应**最后一个 ACK 报文**，先把 ACK 置 1，再把确认应答号填入 server-isn + 1，再发给服务端，这次报文是可以携带应用层数据的，然后客户端处于 ESTABLISHED 状态，服务端在收到客户端的应答报文后也会进入 ESTABLISHED 状态

一共就是 **SYN —— SYN-ACK —— ACK 三次握手**，但**只有第三次握手可以携带数据**，前两次握手是不可以携带数据的，三次握手之后连接就建立完成了，客户端和服务端可以互相发送数据，在 Linux 系统中可以通过 `netstat -napt` 这个命令来查看 TCP 的连接状态

#### 为什么 TCP 是三次握手，而不是两次或者四次？

因为只有三次握手才能保证双方**都**具有接收和发送的能力

**避免历史连接：**

三次握手可以防止旧的重复连接初始化造成混乱，比如客户端先发送了一个 SYN = 90 的报文，但这个报文由于网络阻塞服务端并没有收到，然后客户端又重新向服务端发了一个 SYN = 100 的报文，不是重传 SYN = 90，而是重新发送了一个序列号不同的 SYN 报文

如果是三次握手，当网络拥堵时，旧的 SYN 报文比新的 SYN 报文**先**到达了服务端，那此时服务端就会返回一个 SYN + ACK 报文给客户端，这个报文的确认号是 90 + 1 = 91，但客户端收到后发现 91 并不是自己期望收到的 101，因为新发了 SYN 请求，所以客户端就会发送 RST 报文终止连接

服务端在收到 RST 报文后就会释放 SYN = 90 的连接，然后等收到最新的 SYN = 100 后重新建立连接，从而完成正常的三次挥手，这里的 SYN = 90 就是历史连接，**防止历史连接初始化是使用三次握手最主要的原因**

如果服务端在收到 RST 报文之前先收到了客户端第二次发的新 SYN 报文，那服务端会回 Challenge ACK 报文给客户端，这个报文并不是 ACK 新的 SYN 报文的，而是上一次 SYN 的确认号，也就是 91，所以仍然会触发 RST

如果是**两次握手**，服务端相当于在收到 SYN 报文之后就会进入 ESTABLISHED 状态，也就是说可以给对方发送数据，但这个时候客户端还没有进入 ESTABLISHED 状态，如果客户端判断当前连接是历史连接，那服务端在收到 RST 之前就**白白浪费**了资源在这个历史连接上发送数据，因为**没有中间状态给客户端来阻止历史连接**

如果第三次握手的 ACK 报文丢失了，虽然服务端还是在 SYN-RCVD 状态，但收到客户端的数据之后还是可以建立连接的，因为**客户端发送的数据报文中是有 ACK 标识位和确认号的**，这个确认号就代表确认收到了，所以可以正常建立连接

**同步双方初始序列号：**

**序列号**可以被接收方用来去除重复的数据和根据数据包的序列号按序接收，还可以标识发送出去的数据包中哪些是被对方已经收到的（通过 ACK 报文中的序列号得知）

所以无论是客户端还是服务端，当客户端发送 SYN 时自然需要服务端发送 ACK 来应答，表示 SYN 已经被成功接收，当服务端发送初始序列号给客户端时，也要得到客户端的响应，只有这样一来一回才能确保**双方的初始序列号能被可靠地同步**

而由于服务端在回复客户端 ACK 时可以**顺便**发 SYN，所以就只需要三步而不是四步了，如果是两次握手就只能保证一方的初始序列号能被对方成功接收，而不是双方的

**避免资源浪费：**

如果只有两次握手，当客户端由于网络阻塞重复发送 SYN 报文时，由于没有第三次握手，服务端并不清楚客户端是否收到了自己的 ACK 报文，所以服务端每次收到一个 SYN 就只能**先主动建立一个连接**，就会导致服务端建立了多个冗余的无效连接，造成不必要的资源浪费

#### TCP 连接如何确保可靠性？

TCP 的每个数据包都有一个唯一的**序列号**，确保数据能够**按正确的顺序组装**，接收方会根据序列号将数据组装成正确的数据，即使数据包的接受顺序和发送顺序不同

每个 TCP 数据包还都会附带一个**校验和**，用于检查数据在传输过程中的完整性，如果校验和不匹配，接收方就会丢弃该数据包并请求重传，接收方还会对每个收到的数据包发送**确认应答**，即 ACK

发送方在发送数据时会设置一个**定时器**，如果定时器超时之前没有收到接收方的 ACK，就会**自动重传**

TCP 会通过滑动窗口来进行**流量控制**，确保接收方能处理发送方的数据，还会通过**拥塞控制**机制来控制数据的发送速率，避免网络拥塞

#### 第一次握手如果丢失了，会发生什么？

客户端发送 SYN 报文后如果一直收不到 SYN-ACK，就会触发**超时重传**，重传的 SYN 报文的序列号都是一样的

超时时间是写死在内核里的，要更改就需要重新编译内核，比较麻烦，而最大重传次数则是可以很方便地修改，通常第一次重传是在 1 秒后，第二次 2 秒，第三次 4 秒，每次都是上一次时间的两倍，以此类推，一般来说默认是重传五次，也就是一分钟左右，如果已经到达了最大重传次数，那客户端就会断开连接

#### 第二次握手如果丢失了，会发生什么？

如果第二次握手丢失了，首先客户端是没有收到服务端返回的 SYN-ACK 报文的，所以客户端会以为是自己第一次握手的 SYN 报文丢失了，会触发超时重传 SYN

而服务端由于第二次握手丢失，是收不到第三次握手的，所以服务端也会触发超时重传 SYN-ACK，也就是**两边都会重传**，直到到达了最大重传次数，自动断开连接

#### 第三次握手如果丢失了，会发生什么？

客户端在收到服务端的 SYN-ACK 报文后会给服务端回一个 ACK 报文，如果这个报文丢失了，**服务端会触发超时重传 SYN-ACK**，直到收到第三次握手或者到达最大重传次数，这里客户端的 ACK 报文是不会有重传的，当这个 ACK 报文丢失了，也是由对方来重传相应的报文

#### 什么是 SYN 攻击？该如何避开？

在 TCP 三次握手时，Linux 内核会维护**半连接**和**全连接**两个队列，服务端在收到客户端的 SYN 报文后会创建一个半连接的对象，并把其加入到内核的 SYN 半连接队列中，然后发送 SYN-ACK 给客户端，收到客户端回应的 ACK 报文后再从 SYN 队列中取出一个半连接对象，并创建一个新的全连接对象放到 Accept 队列里，应用就可以通过调用 accept() socket 接口来从 Accept 队列中取出全连接对象

攻击者短时间内伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就会进入 SYN-RCVD 状态，但服务端发送出去的 SYN-ACK 是无法得到未知 IP 主机的 ACK 应答的，所以就会**占满服务端的半连接队列**，导致后续再收到 SYN 报文时就会默认**丢弃**，导致客户端和服务端无法建立连接

避免方式主要有**调大网卡接收数据包的缓冲队列最大值、增大 TCP 半连接队列长度、减少 SYN-ACK 的重传次数和开启 TCP 的 SYN-Cookies 功能**

当 SYN 队列满了之后后续服务端收到 SYN 包时不会丢弃，而是会根据算法算出一个 Cookie 值，放到 SYN-ACK 的序列号里，返回给客户端，等服务端收到 ACK 时再检查是否合法，这样即使被攻击也能保证正常的连接成功建立

#### TCP 四次挥手的过程是什么样的？为什么需要四次？

客户端打算关闭连接，会发送一个 **FIN** 报文给服务端，然后进入 FIN-WAIT-1 状态，服务端在收到该报文后，会向客户端发送一个 **ACK** 应答报文，然后服务端进入 CLOSE-WAIT 状态，客户端在收到服务端的 ACK 报文之后，会进入 FIN-WAIT-2 状态

服务端在处理完数据之后会向客户端再发送一个 **FIN** 报文，之后服务端会进入 LAST-ACK 状态，客户端在收到服务端发送的 FIN 报文后也会回一个 **ACK** 报文，然后进入 **TIME-WAIT** 状态，服务端在收到 ACK 之后就会进入 CLOSE 状态，服务端已经完成了连接的关闭，然后客户端在经过 2 MSL 时间之后就会自动进入 CLOSE 状态，也完成了连接的关闭

由于两个方向各自需要一个 FIN 和一个 ACK，因此是**四次挥手**，要注意的是**只有主动关闭连接的才会有 TIME-WAIT 状态**

在关闭连接时，客户端向服务端发送 FIN 仅仅代表**客户端不再发送数据了，但还能接收数据**，服务端在回复 ACK 之后可能还有数据需要处理和发送，只有等服务端不再发送数据时才会发送 FIN 表示现在同意关闭连接，当然在特定情况下，四次挥手是可以变成三次的

#### 如果第一次挥手丢失了，会发生什么？

客户端在发送完 FIN 之后会进入 FIN-WAIT-1 状态，但如果一直收不到 ACK 的话就会触发**超时重传**机制，如果超过了最大重传次数之后还是没有收到第二次挥手，就会直接进入 CLOSE 状态，**直接关闭连接**

#### 如果第二次挥手丢失了，会发生什么？

由于 ACK 是不会重传的，所以如果第二次挥手丢失，客户端就会触发**超时重传**机制，直到收到第二次挥手或者到达最大的重传次数

#### 如果第三次挥手丢失了，会发生什么？

客户端在收到第二次挥手的 ACK 报文后会进入 FIN-WAIT-2状态，在这个状态等待服务端发送第三次挥手，但这个等待是有时间限制的，如果超时了就会**直接关闭连接**

服务端发送的第三次挥手的 FIN 报文丢失后也会触发**超时重传**，也是一样如果到达了最大重传次数之后就会直接断开连接，而客户端由于一直没收到服务端的第三次握手所以超时之后也会直接关闭连接

#### 如果第四次挥手丢失了，会发生什么？

也是一样如果超时了服务端是会触发**超时重传**的，如果到达了最大重传次数还是没有收到就会直接断开连接，客户端在收到第三次挥手后会进入 TIME-WAIT 状态，开启时长为 2 MSL 的定时器，如果中间再次收到第三次挥手的报文就会**重置定时器**，当超时之后也会直接断开连接

#### Q：为什么 TIME_WAIT 等待的时间是 2 MSL？



#### Q：为什么需要 TIME_WAIT 状态？



#### Q：TIME_WAIT 过多有什么危害？



#### Q：如何优化 TIME_WAIT？



#### Q：服务器出现大量 TIME_WAIT 状态的原因有哪些？



* time_wait 是什么，这种状态是怎么出现的

* 如果站在网络的 TCP 协议层面去看的话，time_wait 是在什么情况下产生的

* 你能讲一下 TCP 四次挥手的详细过程吗

* time_wait 会出现在连接的哪一方？

* 那如果站在 TCP 连接层面来看的话，要解决 time_wait 连接数很多的问题，最直接的方式是怎么去优化

#### Q：服务器出现大量 CLOSE_WAIT 状态的原因有哪些？



#### Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？



#### Q：如果已经建立了连接，但是服务端的进程崩溃会发生什么？



## TCP 传输
#### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

MTU 是 IP 层面一个网络包的最大长度，MSS 则是去掉 IP 和 TCP 头部之后，TCP 层面所能容纳的最大网络包数据长度

如果全部都交给 IP 层分片，那**在传输过程中如果某一个 IP 分片丢失，那整个 IP 报文的分片都要重传**，因为 IP 层本身是没有超时重传机制的，当丢失后接收方的 IP 层就无法组装成完整的 TCP 报文，接收方也就无法发送 ACK 给发送方

发送方收不到 ACK，就会触发超时重传，就会重发**整个** TCP 报文（头部 + 数据），而如果有 MSS，**TCP 在建立连接时双方就会协商两边的 MSS 值**，从而在 TCP 层面直接分片，这样后面如果一个 TCP 分片丢失后进行重发也是以更小的 MSS 为单位来的，而不用重传所有的分片，从而提高重传效率

#### TCP 流量控制是怎么实现的？

 主要是用**滑动窗口**，接收方会维护一个接收窗口，发送方会维护一个发送窗口

 **接收窗口**的大小不会超过接收缓存区的大小，并且在每次返回的 ACK 里告知发送方，**发送窗口**的大小也不会超过接收窗口的大小，还不会超过发送缓存区的大小，发送窗口中既有发送了还没确认的消息也有还没发送的消息

#### 能说说拥塞控制是怎么实现的吗？



#### TCP 滑动窗口机制是如何工作的？它在流量控制中有什么作用？



## UDP
#### UDP 怎么实现可靠传输？

UDP 本身是无连接不可靠的传输层协议，但我们可以在**应用层**来模拟 TCP 的可靠性机制，QUIC 就是这样做的

我们可以提供**确认序列号**，通过接收端反馈 ACK 来确认，并保证有序性和完整性，还可以提供**超时重传**，在没有收到 ACK 时重传数据包并计算下一次超时重传时间，另外也可以提供**滑动窗口**机制，允许连续发送多个数据包，通过累计 ACK 来减少通信次数

#### 



#### Q：针对 TCP 应该如何 Socket 编程？



#### Q：listen 时候参数 backlog 的意义？



#### Q：accept 发生在三次握手的哪一步？



#### Q：客户端调用 close 了，连接是断开的流程是什么？



#### Q：没有 accept，能建立 TCP 连接吗？



#### Q：没有 listen，能建立 TCP 连接吗？



#### Q：TCP 的重传、滑动窗口、流量控制和拥塞控制分别是什么？详细说说



#### TCP 的流量和拥塞控制分别是怎么实现的？



#### Q：什么是 TCP 队头阻塞问题？



#### Q：什么是 TCP 半连接队列和全连接队列？



#### Q：如何优化 TCP？



#### Q：如何理解 TCP 是面向字节流协议？如何理解字节流？如何解决粘包？



#### Q：为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？



#### Q：SYN 报文什么时候情况下会被丢弃？



#### Q：已建立连接的TCP，收到SYN会发生什么？



#### Q：如何关闭一个 TCP 连接？



#### Q：四次挥手中收到乱序的 FIN 包会如何处理？



#### Q：在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？



#### Q：在 TIME_WAIT 状态的 TCP 连接，收到 RST 会断开连接吗？



#### Q：TCP 连接，一端断电和进程崩溃有什么区别？



#### Q：拔掉网线后， 原本的 TCP 连接还存在吗？



#### Q：tcp_tw_reuse 为什么默认是关闭的？什么是 TIME_WAIT 状态？为什么要设计 TIME_WAIT 状态？tcptwreuse 是什么？为什么 tcptwreuse 默认是关闭的？



#### Q：HTTPS 中 TLS 和 TCP 能同时握手吗？



#### Q：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？



#### Q：TCP 协议有什么缺陷？


TCP 连接如何确保可靠性？


#### Q：如何基于 UDP 协议实现可靠传输？



#### Q：QUIC 是如何实现可靠传输的？



#### Q：QUIC 是如何解决 TCP 队头阻塞问题的？



#### Q：QUIC 是如何做流量控制的？



#### Q：QUIC 是如何迁移连接的？



#### Q：TCP 和 UDP 可以使用同一个端口吗？TCP 和 UDP 可以同时绑定相同的端口吗？



#### Q：多个 TCP 服务进程可以绑定同一个端口吗？



#### Q：客户端的端口可以重复使用吗？



#### Q：服务端没有 listen，客户端发起连接建立，会发生什么？



#### Q：不使用 listen ，可以建立 TCP 连接吗？



#### Q：没有 accept，能建立 TCP 连接吗？



#### Q：用了 TCP 协议，数据一定不会丢吗？如果会的话，该怎么解决？



#### Q：TCP 四次挥手，可以变成三次吗？什么情况会出现三次挥手？



#### Q：TCP 序列号和确认号是如何变化的？



* TCP 滑动窗口机制是如何工作的？它在流量控制中有什么作用？

* TCP 拥塞控制中的慢启动、拥塞避免、快重传和快恢复阶段分别是什么？它们的作用是什么？

* 什么是网络拥塞？TCP 是如何应对网络拥塞的？



