## 基本概念
#### 什么是 TCP？

TCP 是**面向连接的、可靠的、基于字节流的**传输层通信协议

面向连接是指一定得是一对一才能连接，一对多是无法做到的

可靠是指无论网络链路中出现了什么变化，TCP 都可以保证一个报文一定能够到达接收端

基于字节流是指当消息通过 TCP 传输时，消息可能会被分成多个 TCP 报文，如果接收方不知道**消息边界**，是无法读出有效的消息的，并且 TCP 报文是有序的，当前一个报文没有收到时，即使后面的报文先收到了，也不能直接给应用层去处理，另外对于重复的报文 TCP 会自动丢弃

#### 如何唯一确定一个 TCP 连接？

一个 TCP 连接是由唯一的一个**四元组**所确定的，包括**源地址、源端口、目标地址和目标端口**

其中源地址和目标地址的字段是在 IP 头部中，是通过 IP 协议发送报文给对方主机

源端口和目标端口则是在 TCP 头部中，是告诉 TCP 协议应该把报文发给哪个进程

#### 有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？

理论上最大的连接数是**客户端的 IP 数 * 客户端的端口数**，但服务端最大 TCP 并发连接数是达不到理论上限的

由于每个 TCP 连接都是一个文件，Linux 对可以打开的文件描述符数量分别做了系统级、用户级和进程级的限制，另外每个 TCP 连接也会占用一定内存，而操作系统的内存是有限的

#### 你知道 TCP 和 UDP 吗？它们的区别是什么？分别的应用场景是？

TCP 是**面向连接的、可靠的、基于字节流的**传输协议，它保证数据完整有序到达，而 UDP 是**无连接的不可靠传输协议**，它延迟极低，注重传输速度和简单性

区别则在于**连接方式、可靠性、传输顺序、传输速度、头部开销、流量控制和拥塞控制**

TCP 需要先通过三次握手建立连接（SYN、SYN-ACK、ACK），数据传输完成后还要通过四次挥手释放连接（FIN、ACK、FIN-ACK、ACK），且连接只能一对一，而 UDP 则是直接发送数据包，不需要握手和挥手，还可以**一对多或者多对多**

TCP 通过确认应答、超时重传和校验和来确保数据可靠，UDP 是没有重传机制的，发送即丢弃，可靠性由应用层处理

TCP 通过序列号来保证接收端能按序重组数据，并且是基于字节流的，传输的数据都是二进制的无边界字节串，UDP 不维护数据顺序，接收端可能乱序接收，且是面向报文的，传输的都是有边界的应用层的报文包

TCP 如果数据的大小太大会在传输层进行分片，接收端也是在传输层组装，而 UDP 则是在 IP 层进行分配和组装

TCP 因连接管理、流量控制和重传等机制，传输延迟是比较高的，UDP 没有相应的开销，所以传输速度极快

TCP 的头部最小 20 字节，包含序列号、确认应答号、窗口大小和控制位（ACK、RST——连接出现异常要强制断开、SYN、FIN）等字段，还有可选字段能扩展，UDP 的头部则是**固定** 8 个字节，仅含源端口、目标端口、包长度和校验和（防止收到在网络传输中受损的数据包）

TCP 能通过滑动窗口动态调整发送速率，避免接收方缓冲区溢出，UDP 则无流量控制，可能会因为接收方处理不及时而导致丢包

TCP 通过慢启动、拥塞避免和快速重传等算法来避免网络拥堵，UDP 无拥塞控制，反而可能加剧拥塞

TCP 的应用场景主要在于 HTTP、HTTPS、邮件和文件传输，而 UDP 的则是 DNS 查询、视频音频和在线游戏

#### TCP 和 UDP 可以使用同一个端口吗？

可以，TCP 和 UDP 各自的端口号是**互相独立**的

链路层使用 MAC 地址找到局域网的主机后，网络层使用 IP 地址来寻址网络中互联的主机或路由器，传输层是用端口来寻址，识别统一计算机中同时通信的不同应用

而 TCP 和 UDP 在内核中是两个完全独立的软件模块，当主机收到数据包后可以通过 IP 包头的协议号知道该数据包是 TCP 还是 UDP，从而分配给对应的模块处理，模块处理完报文再根据端口号确定给哪个 TCP 应用还是给 UDP 应用

## 什么是网络拥塞？TCP 是如何应对网络拥塞的？

网络拥塞是指在网络中传输的数据量**超过了**可用带宽或中间设备（如路由器、交换机）的**处理能力**，导致网络性能下降的现象

TCP 的拥塞控制机制主要是通过**慢启动、拥塞避免、快速重传和快速恢复**这四个阶段，动态调整发送速率，从而保证网络的稳定和高效

## TCP 连接
#### TCP 三次握手过程是什么样的？

一开始客户端和服务端都处于 CLOSE 状态，然后服务端会主动监听某个端口，处于 LISTEN 状态

接下来**客户端**会随机初始化序列号 client-isn，并把 SYN 置于 1，表示 SYN 报文，再把这**第一个 SYN 报文**发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，然后客户端处于 SYN-SENT 状态

**服务端**在收到客户端的 SYN 报文后，会先随机初始化自己的序列号 server-isn，再把自己的确认应答号填入 client-isn + 1，再把 SYN 和 ACK 都置 1，再把这**第二个 SYN-ACK 报文**发给客户端，该报文也不含应用层数据，然后服务端处于 SYN-RCVD 状态

**客户端**在收到服务端的报文之后，会再回应**最后一个 ACK 报文**，先把 ACK 置 1，再把确认应答号填入 server-isn + 1，再发给服务端，这次报文是可以携带应用层数据的，然后客户端处于 ESTABLISHED 状态，服务端在收到客户端的应答报文后也会进入 ESTABLISHED 状态

一共就是 **SYN —— SYN-ACK —— ACK 三次握手**，但**只有第三次握手可以携带数据**，前两次握手是不可以携带数据的，三次握手之后连接就建立完成了，客户端和服务端可以互相发送数据，在 Linux 系统中可以通过 `netstat -napt` 这个命令来查看 TCP 的连接状态

#### 为什么 TCP 是三次握手，而不是两次或者四次？

因为只有三次握手才能保证双方**都**具有接收和发送的能力

**避免历史连接：**

三次握手可以防止旧的重复连接初始化造成混乱，比如客户端先发送了一个 SYN = 90 的报文，但这个报文由于网络阻塞服务端并没有收到，然后客户端又重新向服务端发了一个 SYN = 100 的报文，不是重传 SYN = 90，而是重新发送了一个序列号不同的 SYN 报文

如果是三次握手，当网络拥堵时，旧的 SYN 报文比新的 SYN 报文**先**到达了服务端，那此时服务端就会返回一个 SYN + ACK 报文给客户端，这个报文的确认号是 90 + 1 = 91，但客户端收到后发现 91 并不是自己期望收到的 101，因为新发了 SYN 请求，所以客户端就会发送 RST 报文终止连接

服务端在收到 RST 报文后就会释放 SYN = 90 的连接，然后等收到最新的 SYN = 100 后重新建立连接，从而完成正常的三次挥手，这里的 SYN = 90 就是历史连接，**防止历史连接初始化是使用三次握手最主要的原因**

如果服务端在收到 RST 报文之前先收到了客户端第二次发的新 SYN 报文，那服务端会回 Challenge ACK 报文给客户端，这个报文并不是 ACK 新的 SYN 报文的，而是上一次 SYN 的确认号，也就是 91，所以仍然会触发 RST

如果是**两次握手**，服务端相当于在收到 SYN 报文之后就会进入 ESTABLISHED 状态，也就是说可以给对方发送数据，但这个时候客户端还没有进入 ESTABLISHED 状态，如果客户端判断当前连接是历史连接，那服务端在收到 RST 之前就**白白浪费**了资源在这个历史连接上发送数据，因为**没有中间状态给客户端来阻止历史连接**

如果第三次握手的 ACK 报文丢失了，虽然服务端还是在 SYN-RCVD 状态，但收到客户端的数据之后还是可以建立连接的，因为**客户端发送的数据报文中是有 ACK 标识位和确认号的**，这个确认号就代表确认收到了，所以可以正常建立连接

**同步双方初始序列号：**

**序列号**可以被接收方用来去除重复的数据和根据数据包的序列号按序接收，还可以标识发送出去的数据包中哪些是被对方已经收到的（通过 ACK 报文中的序列号得知）

所以无论是客户端还是服务端，当客户端发送 SYN 时自然需要服务端发送 ACK 来应答，表示 SYN 已经被成功接收，当服务端发送初始序列号给客户端时，也要得到客户端的响应，只有这样一来一回才能确保**双方的初始序列号能被可靠地同步**

而由于服务端在回复客户端 ACK 时可以**顺便**发 SYN，所以就只需要三步而不是四步了，如果是两次握手就只能保证一方的初始序列号能被对方成功接收，而不是双方的

**避免资源浪费：**

如果只有两次握手，当客户端由于网络阻塞重复发送 SYN 报文时，由于没有第三次握手，服务端并不清楚客户端是否收到了自己的 ACK 报文，所以服务端每次收到一个 SYN 就只能**先主动建立一个连接**，就会导致服务端建立了多个冗余的无效连接，造成不必要的资源浪费

#### TCP 连接如何确保可靠性？

TCP 的每个数据包都有一个唯一的**序列号**，确保数据能够**按正确的顺序组装**，接收方会根据序列号将数据组装成正确的数据，即使数据包的接受顺序和发送顺序不同

每个 TCP 数据包还都会附带一个**校验和**，用于检查数据在传输过程中的完整性，如果校验和不匹配，接收方就会丢弃该数据包并请求重传，接收方还会对每个收到的数据包发送**确认应答**，即 ACK

发送方在发送数据时会设置一个**定时器**，如果定时器超时之前没有收到接收方的 ACK，就会**自动重传**

TCP 会通过滑动窗口来进行**流量控制**，确保接收方能处理发送方的数据，还会通过**拥塞控制**机制来控制数据的发送速率，避免网络拥塞

#### 第一次握手如果丢失了，会发生什么？

客户端发送 SYN 报文后如果一直收不到 SYN-ACK，就会触发**超时重传**，重传的 SYN 报文的序列号都是一样的

超时时间是写死在内核里的，要更改就需要重新编译内核，比较麻烦，而最大重传次数则是可以很方便地修改，通常第一次重传是在 1 秒后，第二次 2 秒，第三次 4 秒，每次都是上一次时间的两倍，以此类推，一般来说默认是重传五次，也就是一分钟左右，如果已经到达了最大重传次数，那客户端就会断开连接

#### 第二次握手如果丢失了，会发生什么？

如果第二次握手丢失了，首先客户端是没有收到服务端返回的 SYN-ACK 报文的，所以客户端会以为是自己第一次握手的 SYN 报文丢失了，会触发超时重传 SYN

而服务端由于第二次握手丢失，是收不到第三次握手的，所以服务端也会触发超时重传 SYN-ACK，也就是**两边都会重传**，直到到达了最大重传次数，自动断开连接

#### 第三次握手如果丢失了，会发生什么？

客户端在收到服务端的 SYN-ACK 报文后会给服务端回一个 ACK 报文，如果这个报文丢失了，**服务端会触发超时重传 SYN-ACK**，直到收到第三次握手或者到达最大重传次数，这里客户端的 ACK 报文是不会有重传的，当这个 ACK 报文丢失了，也是由对方来重传相应的报文

#### 什么是 SYN 攻击？该如何避开？

在 TCP 三次握手时，Linux 内核会维护**半连接**和**全连接**两个队列，服务端在收到客户端的 SYN 报文后会创建一个半连接的对象，并把其加入到内核的 SYN 半连接队列中，然后发送 SYN-ACK 给客户端，收到客户端回应的 ACK 报文后再从 SYN 队列中取出一个半连接对象，并创建一个新的全连接对象放到 Accept 队列里，应用就可以通过调用 accept() socket 接口来从 Accept 队列中取出全连接对象

攻击者短时间内伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就会进入 SYN-RCVD 状态，但服务端发送出去的 SYN-ACK 是无法得到未知 IP 主机的 ACK 应答的，所以就会**占满服务端的半连接队列**，导致后续再收到 SYN 报文时就会默认**丢弃**，导致客户端和服务端无法建立连接

避免方式主要有**调大网卡接收数据包的缓冲队列最大值、增大 TCP 半连接队列长度、减少 SYN-ACK 的重传次数和开启 TCP 的 SYN-Cookies 功能**

当 SYN 队列满了之后后续服务端收到 SYN 包时不会丢弃，而是会根据算法算出一个 Cookie 值，放到 SYN-ACK 的序列号里，返回给客户端，等服务端收到 ACK 时再检查是否合法，这样即使被攻击也能保证正常的连接成功建立

#### TCP 四次挥手的过程是什么样的？为什么需要四次？

客户端打算关闭连接，会发送一个 **FIN** 报文给服务端，然后进入 **FIN-WAIT-1** 状态，服务端在收到该报文后，会向客户端发送一个 **ACK** 应答报文，然后服务端进入 **CLOSE-WAIT** 状态，客户端在收到服务端的 ACK 报文之后，会进入 **FIN-WAIT-2** 状态

服务端在处理完数据之后会向客户端再发送一个 **FIN** 报文，之后服务端会进入 **LAST-ACK** 状态，客户端在收到服务端发送的 FIN 报文后也会回一个 **ACK** 报文，然后进入 **TIME-WAIT** 状态，服务端在收到 ACK 之后就会进入 CLOSE 状态，服务端已经完成了连接的关闭，然后客户端在经过 2 MSL 时间之后就会自动进入 CLOSE 状态，也完成了连接的关闭

由于两个方向各自需要一个 FIN 和一个 ACK，因此是**四次挥手**，要注意的是**只有主动关闭连接的才会有 TIME-WAIT 状态**

在关闭连接时，客户端向服务端发送 FIN 仅仅代表**客户端不再发送数据了，但还能接收数据**，服务端在回复 ACK 之后可能还有数据需要处理和发送，只有等服务端不再发送数据时才会发送 FIN 表示现在同意关闭连接，当然在特定情况下，四次挥手是可以变成三次的

#### 如果第一次挥手丢失了，会发生什么？

客户端在发送完 FIN 之后会进入 FIN-WAIT-1 状态，但如果一直收不到 ACK 的话就会触发**超时重传**机制，如果超过了最大重传次数之后还是没有收到第二次挥手，就会直接进入 CLOSE 状态，**直接关闭连接**

#### 如果第二次挥手丢失了，会发生什么？

由于 ACK 是不会重传的，所以如果第二次挥手丢失，客户端就会触发**超时重传**机制，直到收到第二次挥手或者到达最大的重传次数

#### 如果第三次挥手丢失了，会发生什么？

客户端在收到第二次挥手的 ACK 报文后会进入 FIN-WAIT-2状态，在这个状态等待服务端发送第三次挥手，但这个等待是有时间限制的，如果超时了就会**直接关闭连接**

服务端发送的第三次挥手的 FIN 报文丢失后也会触发**超时重传**，也是一样如果到达了最大重传次数之后就会直接断开连接，而客户端由于一直没收到服务端的第三次握手所以超时之后也会直接关闭连接

#### 如果第四次挥手丢失了，会发生什么？

也是一样如果超时了服务端是会触发**超时重传**的，如果到达了最大重传次数还是没有收到就会直接断开连接，客户端在收到第三次挥手后会进入 TIME-WAIT 状态，开启时长为 2 MSL 的定时器，如果中间再次收到第三次挥手的报文就会**重置定时器**，当超时之后也会直接断开连接

#### 为什么 TIME_WAIT 等待的时间是 2 MSL？

**MSL** 是 Maximum Segment Lifetime，报文最大生存时间，它是**任何报文在网络上存在的最长时间**，之所以是 2 MSL 是因为网络中可能存在来自发送方的数据包，当这些包被接收方处理后服务端又会向客户端发送响应，所以**一来一回**刚好要等待**两倍**的时间

这相当于**至少允许报文丢失一次**，比如有一个 ACK 在一个 MSL 内丢失了，这时服务端重发的 FIN 会在第二个 MSL 内到达，所以 TIME-WAIT 状态的连接可以应对

2 MSL 是从客户端接收到 FIN 并发送了 ACK 之后开始计时的，如果在 TIME-WAIT 时间内收到了服务端重发的 FIN，那么 2 MSL 就会重新计时

#### TIME-WAIT 是什么，这种状态是怎么出现的

TIME-WAIT 是 TCP 连接的**主动关闭方**在完成四次挥手之后短暂停留的一个状态，是用来确保最后一个 ACK 能被被动关闭方接收并防止历史连接中的数据被错误接收的

**TIME-WAIT 只会出现在主动发起关闭 TCP 连接的那一方**，常见于客户端

这种状态是在客户端收到服务端发送的第三次挥手的 FIN 报文，并向服务端发送了 ACK 报文之后会进入的，可以用 netstat -anp | grep TIME_WAIT | wc -l 来在实际开发中查看这个状态

还有一种特殊情况是**两端几乎同时向对方发送 FIN**，此时就要看两端哪一边满足：**发出了 FIN、收到了对方的对自己 FIN 的 ACK、给对方的 FIN 回复了 ACK**，这三个条件，只要满足了，就会进入 TIME-WAIT 状态

所以可能的链路是 ESTABLISHED —— FIN-WAIT-1 ——  CLOSING（发出了 FIN，收到了 FIN，回复了 ACK，但还没有收到对方对自己 FIN 的 ACK）—— TIME-WAIT，或者是 ESTABLISHED —— FIN-WAIT-1 —— FIN-WAIT-2 —— 收到 FIN 并回复 ACK —— TIME-WAIT，也就是说四次挥手完成之后会有一方或两方发送/接收最后的 ACK，再进入 TIME-WAIT

#### 为什么需要 TIME_WAIT 状态？

**防止历史连接中的数据被新的连接错误接收：**

**序列号**是用来标识发送的数据流的一个头部字段，它是用来保证消息的顺序性和可靠性的，而**初始序列号**则是在 TCP 建立连接时客户端和服务端基于时钟各自生成的随机数，用来保证每个连接都有不同的初始序列号

但序列号和初始序列号都不是无限递增的，它们都会发生回绕为初始值的情况，也就是说**我们无法根据序列号来判断新老数据**

如果 TIME-WAIT 没有等待时间或者等待时间过短，那服务端在连接关闭之前发送的历史数据，由于网络延迟，是**在服务端以相同的四元组打开了新连接之后才到达的**，而且这个历史数据报文的序列号还**刚好在客户端的接收窗口内**的话，客户端就会正常接收这个报文，就导致了**数据错乱**的问题

TIME-WAIT 持续了 2 MSL 这个时间足以让两个方向上的数据包都被完全丢弃，使得历史连接的数据包在网络中都自然消失，这样再出现的数据包就一定是新连接产生的了

**保证被动关闭连接的一方能正确关闭：**

TIME-WAIT 在等待足够的时间后可以确保最后的 ACK 能让被动关闭方接收，如果没有 TIME-WAIT，客户端在发完最后一次 ACK 后就直接进入 CLOSE 状态的话，如果这个 ACK 报文丢失了，服务端重传 FIN，但此时客户端已经关闭，收到 FIN 之后就会返回 **RST** 报文

而服务端收到这个 RST 是会将其解释为一个**错误**的，这对于一个可靠的协议来说并不是一个优雅的终止方式，所以客户端必须等待足够长的时间来保证服务端能收到 FIN

#### TIME_WAIT 过多有什么危害？

主要是**占用系统资源**，比如文件描述符、内存、CPU、线程什么的，以及还会**占用端口资源**，端口资源也是有限的

如果**客户端**的 TIME-WAIT 状态过多，导致占满了所有的端口，那么就**无法向目标 IP 和目标端口都一样的服务端发起连接了**，因为自身的端口号数量不够没办法用来组成不同的四元组，TCP 是靠四元组来唯一标识一个连接的

但在这种场景下，只要连接的是不同的服务端，那客户端的端口还是可以被重复使用的，也就是客户端还是可以向其他服务端发起连接的

如果**服务端**的 TIME-WAIT 过多，并不会导致端口资源受限，因为**服务端只监听一个端口**，理论上服务端还可以建立很多连接，但 TCP 连接过多也会占用系统资源

#### 服务器出现大量 TIME_WAIT 状态的原因有哪些？

**HTTP 没有使用长连接：**

大多数 Web 服务的实现，无论是哪一方禁用了 HTTP Keep-Alive，**都是由服务端来主动关闭连接的**，那么此时服务端自然就会出现 TIME-WAIT 状态的连接

而 Keep-Alive 的初衷是为客户端后续的请求重用连接，如果在某次**请求中** header 携带了关闭连接的信息，那不再重用这个连接的时机自然也就只有在服务端了，所以在服务端来关闭连接是比较自然的

如果是**服务端禁用**了 Keep-Alive，那**为了减少一次系统调用**，也是服务端主动关闭连接，因为如果是客户端主动的话那服务端后续还要再读一次事件才能知道连接已经关闭

所以当服务端出现大量 TIME-WAIT 时可以检查一下是否客户端和服务端都开启了 HTTP Keep-Alive

**HTTP 长连接超时：**

如果客户端在完成一个请求后在超时时间内都没有再发起新的请求，那一旦超时服务端就会主动关闭连接，就会出现 TIME-WAIT 状态的连接

所以可以检查是否是因为网络问题导致客户端发送的数据一直没有被服务端接收到，导致了 HTTP 长连接超时

**HTTP 长连接请求数量到达上限：**

一个长连接能处理的请求数量是有上限的，一旦超过上限服务端就会主动关闭这个长连接，所以一旦遇到一些 **QPS 比较高的场景**，那这个**上限值如果刚好比较低**的话，长连接就会很频繁地被关闭，从而导致出现大量的 TIME-WAIT

#### 如果站在 TCP 连接层面来看的话，要解决 TIME_WAIT 连接数很多的问题，最直接的方式是怎么去优化

**提升单个连接利用率：**

**同样的请求量用尽量少的 TCP 连接来承载**，就是最直接的方式，也就是在一个 TCP 连接上跑多次请求，比如使用 Keep-Alive、HTTP 2.0 或 gRPC，而不是一次请求开一个连接，然后用完就关

TIME-WAIT 是绑定在一个 TCP 连接上的，也就是一个唯一的四元组上，如果是一万个请求每秒，那每个请求都新建一个连接和只保持一百个长连接，对于服务器的开销和 TIME-WAIT 的数量肯定是完全不一样的

如果使用的是 HTTP 1.1，那就要在客户端和服务端都开启 Keep-Alive 功能，客户端也要有连接池，不要每次都手动创建然后立马关闭，如果是 HTTP 2.0 或者 gRPC 那就能天然复用了，一条 TCP 上有多条 stream，只要复用别被自己关掉就是，其实就是尽量不要频繁创建新的四元组并主动发 FIN

**不要主动关闭：**

TIME-WAIT 是只会出现在主动关闭连接的那一方的，所以可以**让对端成为主动关闭者，自己少发 FIN**，那 TIME-WAIT 自然就只会出现在对方那里了

比如客户端不主动关闭，由服务端在长连接空闲超时后关闭连接，或者反过来让网关/中间件来承担 TIME-WAIT，这样这个状态就可以被比如代理吃掉，从而减少业务机器上的 TIME-WAIT 状态

**Linux 内核参数：**

实在不行的情况下，我们可以在主动发起连接的那方扩大可用的本地端口范围，比如 `sysctl net.ipv4.ip_local_port_range` 来看当前范围，然后 `sysctl -w net.ipv4.ip_local_port_range="10000 65000"` 调大一点，允许这台机器在同一个远程端口上同时利用更多不同的本地端口，从而间接允许更多未完全回收的四元组共存

或者也可以**复用**一部分 TIME-WAIT，通过 `sysctl -w net.ipv4.tcp_tw_reuse=1` 这个命令来让主动发起连接的一方，允许复用处于 TIME-WAIT 的 socket 给新的连接用，但使用之前要先用 `net.ipv4.tcp_timestamps=1` 打开 TCP 对时间戳的支持，因为重复的数据包会在时间戳过期之后被自然丢弃，从而避免历史报文污染新连接的问题

也可以调整 `net.ipv4.tcp_max_tw_buckets` 这个参数，它是 TIME_WAIT socket 的上限，超过会直接丢弃旧的 TIME_WAIT，但有可能会有旧连接的 FIN/ACK 处理不完全，看到奇怪的 RST

#### 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？

**CLOSE-WAIT 是被动关闭方才会有的状态**，如果被动方**没有调用 close() 函数**来关闭连接，也就无法发出 FIN 报文，也就无法使 CLOSE-WAIT 变成 LAST-ACK 状态

如果服务端出现了大量的 CLOSE_WAIT 状态，那说明服务端的程序没有调用 close() 函数来关闭连接，也就是说**一般是代码的问题**

一个普通的 TCP 服务端流程图：

![TCP-Linux-flow](TCP-Linux-flow.png)

如果**没有将服务端 Socket 注册到 epoll**，那有新连接到来时服务端是无法感知到这个事件的，也就无法获取到已连接的 Socket，也就无法对 Socket 调用 close() 了

如果**在新连接到来时没有调用 accept() 获取这个这个新连接的 Socket**，当有大量客户端主动断开连接时，服务端也是没有机会对这些 Socket 调用 close() 的，从而导致服务端出现了大量 CLOSE_WAIT 状态的连接，这种情况可能是服务端在执行 accept() 之前代码就卡在了某一个逻辑或者提前抛出了异常

如果**在通过 accept() 获取已经连接的 Socket 之后没有将其注册到 epoll**，那后续收到 FIN 报文时服务端也是没办法感知到这个事件的，也就没办法调用 close()

最后一种可能就是在发现客户端关闭连接之后服务端因为代码卡在某个逻辑或者漏处理，导致了死锁什么的情况，所以**没有调用 close()**

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

**TCP 也有 Keep-Alive 机制**，跟 HTTP 的差不多，只是事件间隔会比较久，并且 TCP 是会发送**探测报文**给对端的，如果相应了那定时器就会被重置

如果对端主机宕机并重启，对端可以响应但由于没有该连接的有效信息，所以会直接回复一个 **RST** 来让 TCP 快速发现该连接已经被重置

如果是对端主机宕机，或者是其他原因导致报文不可达，那就是走正常的 Keep-Alive，而如果是进程崩溃，那**操作系统**在回收进程资源时会发送 FIN 报文

#### 如果已经建立了连接，但是服务端的进程崩溃会发生什么？

TCP 的连接信息是由**内核**维护的，所以进程崩溃之后内核会回收该进程所有的 TCP 连接资源，并完成四次挥手的所有过程，并不需要进程的参与

#### TCP 的 Keep-Alive 和 HTTP 的 Keep-Alive 是一个东西吗？它们之间有什么区别？

HTTP 的 Keep-Alive 是指 **HTTP 的长连接**，使客户端能在一个 TCP 连接中发送多个请求和响应，避免了多次建立和关闭连接的开销，它是通过请求头中的 connection: keep-alive 实现的，是在应用层的

TCP 的 Keep-Alive 是 **TCP 的保活机制**，它是用于在 TCP 连接上检测空闲时的连接状态的机制，当 TCP 建立连接后，如果一段时间内没有任何数据传输，服务端就会发送探测包来看连接状态是否有效

#### 下方偏底层细节，待整理
#### Q：针对 TCP 应该如何 Socket 编程？



#### Q：listen 时候参数 backlog 的意义？



#### Q：accept 发生在三次握手的哪一步？



#### Q：客户端调用 close 了，连接是断开的流程是什么？



#### Q：没有 accept，能建立 TCP 连接吗？



#### Q：没有 listen，能建立 TCP 连接吗？


## TCP 传输
#### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

MTU 是 IP 层面一个网络包的最大长度，MSS 则是去掉 IP 和 TCP 头部之后，TCP 层面所能容纳的最大网络包数据长度

如果全部都交给 IP 层分片，那**在传输过程中如果某一个 IP 分片丢失，那整个 IP 报文的分片都要重传**，因为 IP 层本身是没有超时重传机制的，当丢失后接收方的 IP 层就无法组装成完整的 TCP 报文，接收方也就无法发送 ACK 给发送方

发送方收不到 ACK，就会触发超时重传，就会重发**整个** TCP 报文（头部 + 数据），而如果有 MSS，**TCP 在建立连接时双方就会协商两边的 MSS 值**，从而在 TCP 层面直接分片，这样后面如果一个 TCP 分片丢失后进行重发也是以更小的 MSS 为单位来的，而不用重传所有的分片，从而提高重传效率

#### TCP 流量控制是怎么实现的？

主要是用**滑动窗口**，接收方会维护一个接收窗口，发送方会维护一个发送窗口

**接收窗口**的大小不会超过接收缓存区的大小，并且在每次返回的 ACK 里告知发送方，**发送窗口**的大小也不会超过接收窗口的大小，还不会超过发送缓存区的大小，发送窗口中既有发送了还没确认的消息也有还没发送的消息

#### TCP 拥塞控制中的慢启动、拥塞避免、快重传和快恢复阶段分别是什么？它们的作用是什么？

**慢启动：**

TCP 在新连接建立后开始传输数据时的初始阶段，目的是逐步探测网络的可用带宽，防止过快发送数据或在开始时发送过多数据导致网络拥塞

**拥塞避免：**

当 cwdn 达到慢启动的阈值后，为避免发送速率增长过快进入拥塞，TCP 会改为线性增长的模式，从而通过更谨慎的方式探测网络的最大可用贷款

**快速重传：**

是 TCP 的一种优化机制，用于在检测到丢包后快速重传丢失的数据包，而无需等待超时，判断的依据是接收到**三个**重复的 ACK，从而减少丢包导致的中断的等待时间

**快速恢复：**

是结合快速重传的一个阶段，避免丢包重传后重新进入慢启动，它通过调整 cwnd 和 ssthresh 来快速恢复到拥塞避免状态，从而减少丢包对发送速率的影响

这些拥塞控制的方法在保证了数据可靠传输的同时，充分利用了网络带宽，通过动态调整发送速率避免了发送方过度占用网络资源，减少了丢包后的等待时间，提高了数据传输的连续性

#### 可以详细介绍一下 TCP 的重传机制吗？



#### 能说说拥塞控制是怎么实现的吗？

**慢启动：**

在初始阶段，TCP 发送方会以较小的发送窗口传输数据，随着每次成功收到确认数据就会**指数级**增大发送窗口的大小，从而确保在网络发送初期能谨慎地逐步增加发送窗口的大小，避免引起网络拥塞

**拥塞避免：**

到达**慢启动的阈值**后就会进入拥塞避免阶段，发送窗口的大小不再是指数级增长，而是**线性增长**，从而避免引起网络拥塞

**快速重传：**

发送方**连续收到相同的确认**时会认为出现了数据包丢失，会迅速**重新传输**未确认的数据包，**不用等待超时**，从而更快地恢复拥塞导致的数据包丢失

**快速恢复：**

快速重传之后就会进入快速恢复阶段，发送方不会回到慢启动阶段，而是将慢启动阈值设置为当前窗口一半的大小，并将拥塞窗口大小设置为慢启动阈值加上已经确认但未被快速重传的数据块的数量，这会有助于从拥塞中更快地恢复

#### TCP 滑动窗口机制是如何工作的？它在流量控制中有什么作用？

TCP 滑动窗口是一种用于流量控制的技术，它可以确保**数据的发送不会超出接收方的处理能力**，它通过动态调整数据的发送量，来让数据传输更加高效的同时避免网络拥堵

随着接收方对已收到数据的确认，发送方的窗口范围会向前滑动，从而允许发送新的数据，接收方也会动态调整窗口的大小，发送方会根据接收方的接收能力调节数据发送速率

## UDP
#### UDP 怎么实现可靠传输？

UDP 本身是无连接不可靠的传输层协议，但我们可以在**应用层**来模拟 TCP 的可靠性机制，QUIC 就是这样做的

我们可以提供**确认序列号**，通过接收端反馈 ACK 来确认，并保证有序性和完整性，还可以提供**超时重传**，在没有收到 ACK 时重传数据包并计算下一次超时重传时间，另外也可以提供**滑动窗口**机制，允许连续发送多个数据包，通过累计 ACK 来减少通信次数

#### 








#### TCP 的流量和拥塞控制分别是怎么实现的？



#### Q：什么是 TCP 队头阻塞问题？



#### Q：什么是 TCP 半连接队列和全连接队列？



#### Q：如何优化 TCP？



#### Q：如何理解 TCP 是面向字节流协议？如何理解字节流？如何解决粘包？



#### Q：为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？



#### Q：SYN 报文什么时候情况下会被丢弃？



#### Q：已建立连接的TCP，收到SYN会发生什么？



#### Q：如何关闭一个 TCP 连接？



#### Q：四次挥手中收到乱序的 FIN 包会如何处理？



#### Q：在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？



#### Q：在 TIME_WAIT 状态的 TCP 连接，收到 RST 会断开连接吗？



#### Q：TCP 连接，一端断电和进程崩溃有什么区别？



#### Q：拔掉网线后， 原本的 TCP 连接还存在吗？



#### Q：tcp_tw_reuse 为什么默认是关闭的？什么是 TIME_WAIT 状态？为什么要设计 TIME_WAIT 状态？tcptwreuse 是什么？为什么 tcptwreuse 默认是关闭的？



#### Q：HTTPS 中 TLS 和 TCP 能同时握手吗？



#### Q：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？



#### Q：TCP 协议有什么缺陷？


#### Q：如何基于 UDP 协议实现可靠传输？



#### Q：QUIC 是如何实现可靠传输的？



#### Q：QUIC 是如何解决 TCP 队头阻塞问题的？



#### Q：QUIC 是如何做流量控制的？



#### Q：QUIC 是如何迁移连接的？



#### Q：TCP 和 UDP 可以使用同一个端口吗？TCP 和 UDP 可以同时绑定相同的端口吗？



#### Q：多个 TCP 服务进程可以绑定同一个端口吗？



#### Q：客户端的端口可以重复使用吗？



#### Q：服务端没有 listen，客户端发起连接建立，会发生什么？



#### Q：不使用 listen ，可以建立 TCP 连接吗？



#### Q：没有 accept，能建立 TCP 连接吗？



#### Q：用了 TCP 协议，数据一定不会丢吗？如果会的话，该怎么解决？



#### Q：TCP 四次挥手，可以变成三次吗？什么情况会出现三次挥手？



#### Q：TCP 序列号和确认号是如何变化的？




