## 索引
#### 什么是索引？

索引是**帮助存储引擎快速获取数据的一种数据结构**，索引就是数据的目录

索引和数据一样，都位于存储引擎中

#### 索引有哪几种？
**一个索引是可以同时属于好几类的**，比如主键索引既是 B+ 树索引，又是聚簇索引，通常又是一个联合索引或单列索引

* 按数据结构：
  * **B+ 树索引**
    * 基于 **B+ 树**的索引结构，**所有的数据（或主键）都出现在叶子节点，非叶子节点只存索引键 + 指针**
    * 叶子节点里的数据是**按照主键顺序**存放的
    * 叶子节点之间是**双向链表**，层高一般很**低**，三到四层就可以覆盖几百万行，I/O 次数少，范围查询效率高
  * **哈希索引**
    * 用一个**哈希函数**把索引列映射到哈希表的桶里，查找是算哈希值、定位桶，然后在桶里线性查找
    * **只适合等值查询，不支持范围查询**，因为哈希之后是没有顺序概念的，且哈希冲突会影响性能
    * 本质上是一张哈希表，MEMORY 引擎支持显式哈希索引，InnoDB 更多是内部通过**自适应哈希索引**来加速热点数据访问，它会在内存里对热点页自动建一层哈希来加速访问，但是是**没办法手动创建**的
  * **全文索引**
    * 主要用于**长文本**的搜索，底层是**倒排索引**，是**把词项映射到包含这个词的文档或行列表**
    * 可以做分词和相关性排序，适合做某个字符串是否出现在文本中这种**模糊查询**
* 按物理存储：
  * **聚簇索引（主键索引）**
    * 数据本身**按索引 key 的顺序存储**，表数据**按照主键的顺序**存储在 B+ 树的**叶子节点**上，叶子节点存的是**完整的行数据**
    * 也就是说 InnoDB 的**数据文件本身就是一个按主键排序的 B+ 树**，非叶子节点记录主键值和指针，叶子节点存完整行数据，**这棵树就是聚簇索引**
    * **一张表只能有一个聚簇索引**，最好用**自增整型**来做主键，避免频繁页分裂
  * **二级索引（辅助索引）**
    * 除了聚簇索引**以外**的其他 B+ 树索引都是二级索引，**叶子节点存的是索引列 + 主键列**
    * 查二级索引时，**先在二级索引树上定位到叶子节点，然后通过主键回聚簇索引查完整行数据**，也就是要查找两个 B+ 树才能找到数据，这被称为**回表**
    * 一张表可以有**多个**二级索引
  * **覆盖索引**
    * 在二级索引的基础上，**能在二级索引的 B+ 树就能满足查询所需的所有列**，相当于索引包含了要查询的值，就不需要回表查聚簇索引
    * 这样查询**只需要访问二级索引树**，减少了 I/O 次数，提升查询性能
* 按字段特性：
  * **主键索引**（默认使用 B+ 树）
    * `PRIMARY KEY (index_column_1)`
    * **唯一标识一行数据，不能为空**，在 InnoDB 中主键索引就是聚簇索引
    * **一张表只能有一个主键**，一旦确定就不应该频繁修改
  * **唯一索引**
    * `UNIQUE KEY(index_column_1,index_column_2,...)`
    * `CREATE UNIQUE INDEX index_name ON table_name (index_column_1, index_column_2, ...);`
    * 确保某一列或某些列的组合值在表内**不重复**
    * **允许有 NULL 值**，但多个 NULL 被认为是不重复的
    * 同一张表可以有**多个**唯一索引，底层一般也是用 B+ 树实现
    * 适合用于用户手机号、邮箱、身份证号等天然唯一的字段
  * **普通索引**
    * `INDEX(index_column_1,index_column_2,...)`
    * `CREATE INDEX index_name ON table_name (index_column_1, index_column_2, ...);`
    * 最普通的一种索引，只负责加速查询，不保证唯一性
    * **可以有重复值和 NULL 值**
  * **前缀索引**
    * `CREATE TABLE table_name(column_list, INDEX(column_name(length)));`
    * `CREATE INDEX index_name ON table_name (column_name(length));`
    * 对**字符型字段**，如 CHAR、VARCHAR、TEXT，**只取前 N 个字符建立索引**，而不是整个列
    * 可以节省存储空间和内存，但会降低索引的选择性，不能保证真正唯一
    * 在 select 需要完整值时，仍然需要回表查询完整数据
    * 只能保证**前缀范围内**有序，不支持后续字符的排序和范围查询
* 按字段个数：
  * **单列索引**
    * 只包含一个列的索引
    * 适合单字段查询频繁的场景
  * **联合索引（复合索引）**
    * `CREATE INDEX index_product_no_name ON products (product_no, product_name);`
    * 索引 key 同时包含**多个列**，B+ 树是**按照这些列的组合值从左到右排序的**，可以多个前缀，也可以部分列
    * 在建立联合索引时，要**把区分度大的字段排在前面**，提高索引的选择性
    * 遵循**最左前缀原则**，查询条件必须从最左边的列开始才能使用索引，不符合最左前缀之所以会失效是因为**索引树是按列的组合值排序的**，跳过最左边的列就无法利用索引的有序性，**利用索引的前提是索引里的 key 是有序的**
    * 并且**只有等值条件才能继续往后匹配**，遇到**范围查询**则在范围查询字段后面的字段是无法利用联合索引的，因为只有最左边的的列是有序的，右边的字段的值在范围内是无序的
    * 但如果是 `select * from t_table where a >= 1 and b = 2` 这样的**大于等于**的范围查询，虽然在符合 `a >= 1` 条件的二级索引记录的范围里，b 字段的值是无序的，但是对于**符合 `a = 1` 的二级索引记录的范围里**，b 字段的值是**有序**的（先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序），所以这条查询语句 a 和 b 字段都用到了联合索引进行索引查询
    * 如果是 `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，由于在 MySQL 中的 BETWEEN 是**包含边界值**的，所以这条查询语句 a 和 b 字段都用到了联合索引进行索引查询
    * 如果是 `SELECT * FROM t_user WHERE name like 'j%' and age = 22`，在符合前缀为 'j' 的 name 字段的二级索引记录的范围内，age 字段的值是无序的，但是对于符合 `name = 'j'` 的二级索引记录的范围里，age 字段的值是有序的（先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序），所以在确定需要扫描的二级索引的范围时，**可以通过 age 字段来进一步缩小范围**，所以这条查询语句 name 和 age 字段都用到了联合索引进行索引查询
    * 综上，联合索引的**最左匹配（前缀）原则**在遇到**大于或小于**时，只有使用了范围查询的字段可以用到联合索引，其后面的字段是用不到的
    * 但如果是**大于等于、小于等于、BETWEEN 或 like 前缀匹配**的范围查询时，联合索引是会生效的
    * 在联合索引的 B+ 树中找到第一个满足条件的主键值之后，后续判断其他条件时是可以**在联合索引遍历过程中就直接判断**，过滤掉不满足条件的记录，而不是回到主键索引中判断，从而减少回表次数，这被称为**索引下推**，执行计划里出现了 **Extra** 为 **Using index condition** 时就说明启用了索引下推优化

#### 针对下面这条 SQL，怎么通过索引来提高查询效率？`select * from order where status = 1 order by create_time asc`

**给 status 和 create_time 建立一个联合索引**，从而避免 MySQL 发生**文件排序**，直接让根据 status 筛选后的数据就是按照 create_time 排序好的，从而提升查询效率

在查询时，如果只用到 status 的索引，由于这条语句还需要对 create_time 进行排序，这时就会使用 **filesort**

#### 什么时候需要创建索引，什么时候不需要创建索引？

索引最大的好处就是**提高查询速度**，但索引也是有**缺点**的：

* 需要**占用物理空间**，数量越大，占用空间越大
* **创建和维护索引需要耗费时间**，并且时间会随着数据量的增加而增加
* 会**降低表的增删改的效率**，因为 B+ 树为了维护索引有序性，每次增删改索引都会进行动态维护

**适合使用索引的场景：**

* 字段有唯一性限制，比如商品编码
* 经常用于 **where** 查询条件的字段
  * 能提升整个表的查询速度
  * 如果查询条件不止一个字段，可以建立联合索引
* 经常用于 **ORDER BY 和 GROUP BY** 的字段
  * 在查询时可以避免一次排序
  * 建立索引之后在 B+ 树中的记录都是排序好的

**不适合使用索引的场景：**

* where、group by、order by 中用不到的字段
  * 索引的价值是快速定位，如果起不到定位作用的字段通常是不需要创建索引的
* **字段的选择性很低**
  * 比如性别、年龄等，索引的选择性越低，使用索引的效率就越低，甚至会比全表扫描还慢
* **表数据很少时**
* **经常被更新的字段**
  * 频繁更新会导致索引频繁维护，影响性能

#### 优化索引的方法有哪些？

**前缀索引优化：**

在一些**大字符串**的字段作为索引时，使用前缀索引可以**减少索引字段大小**，增加一个索引页中存储的索引值，有效提高索引的查询速度

但前缀索引不能被用作覆盖索引，并且 order by 也无法使用前缀索引

**覆盖索引优化：**

只通过 B+ 树的叶子节点就能满足查询所需的所有列，从二级索引中就能查询到记录，从而**避免回表**查询，减少了 I/O 次数，提高查询效率

**主键索引自增：**

在 B+ 树中，同一个叶子节点内的各个数据是**按照主键顺序存放的**，如果使用自增主键，那每次插入一条新纪录时，都是追加操作，而不需要重新移动数据，从而**避免页分裂**

页分裂是指如果每次插入时主键的索引值都是**随机**的，那插入时就有可能会插入到现有数据页**中间的某个位置**，导致需要**移动其他数据来满足新数据的插入**（因为 B+ 树的叶子节点是有序的），页分裂会造成大量的**内存碎片**，导致索引结构不紧凑，从而影响查询效率

![page-split](page-split.png)

另外，主键字段的**长度**越小，二级索引的叶子节点也就越小（二级索引的叶子节点存放的是主键值），这样二级索引占用的空间也就越小

**索引设置为 NOT NULL：**

如果存在 NULL，优化器在做索引选择时就会更加复杂并且更难优化，因为 **NULL 需要单独处理**，比如在进行索引统计时，count 会忽略 NULL 值

并且 NULL 值是一个没有意义的值，它会占用物理空间

**防止索引失效：**

* 避免在索引列上进行**函数**操作、**计算**或**类型转换**
* 避免使用**左或者左右模糊匹配**的 like 查询
* 联合索引的使用要遵循**最左前缀原则**
* 避免在 where 子句中在 or 前的条件列是索引列，而 or **后**的条件列**不是**索引列

通过 **EXPLAIN** 分析查询语句，执行计划有以下参数：

* possible_keys
  * 查询时可能使用的索引列表
* key
  * 实际使用的索引
  * 如果为 NULL，说明没有使用索引
* key_len
  * 使用的索引长度
* rows
  * 扫描的数据行数
* **type**
  * 找到所需数据时使用的扫描方式
  * 常见扫描类型的执行效率从低到高：
  * ALL
    * 全表扫描
  * index
    * 全索引扫描
    * 和 all 差不多，是对**索引表**进行全表扫描，不再需要对数据排序，但开销仍然很大
  * range
    * 索引范围扫描，**使用索引的范围查询**
    * 要尽可能让 SQL 查询可以使用到 range 这一级别及以上的扫描方式
  * ref
    * 非唯一索引扫描，或者是唯一索引的非唯一性前缀
    * 索引列的值并不唯一，仍要进行目标值附近的小范围扫描
  * eq_ref
    * 唯一索引扫描
    * 使用主键或唯一索引时的访问方式，通常使用在**多表联查**中，即 JOIN
  * const
    * 使用了主键或者唯一索引与常量值进行比较
* extra
  * 额外信息
  * **Using filesort**
    * 查询语句中包含 group by，并且无法利用索引完成排序操作
    * MySQL 需要进行额外的排序操作
  * **Using temporary**
    * 使用了临时表保存中间结果，在对查询结果排序时 MySQL 使用了临时表
    * 常见于排序 order by 和分组 group by 操作
  * **Using index**
    * 覆盖索引
    * 查询只使用了索引树就能满足，不需要回表查询

#### 性别和年龄要不要建立索引，以及记录的如果是初中生的年龄，还要不要建立索引？

一般都**不值得**给性别和年龄单独建索引，这两个字段的**选择性都太低了**，它们更多是**作为联合索引中的后缀辅助字段**

索引最主要的索引就是排除大量不相关行的，索引本身也是有成本的，另外年龄最大的问题是它是会**改变**的，每经过一年理论上所有人的年龄都要 update 一遍，那对应的索引页也要全部重建或者调整，在实际开发中更多是比如用**生日**或者**入学年份**来建索引，如果只有初中生的话那年龄的值也会非常少，这点上跟性别是类似的

#### 是不是有索引就一定会走，优化器选择走索引的边界值是多少？

不是的，MySQL 的优化器会对**走索引 + 回表**和**直接全表扫描**这两种方案进行**成本估算**，选择成本更低的方案来执行查询，**一般来说并没有一个明确的边界值**，只有当某个条件能把数据过滤到**比较小的比例**时，比如几个百分点以内，走索引才有明显优势

如果这个条件本身**选择性很差**，比如性别、年龄等，或者**能命中表里 20 - 30% 甚至更多的行**，而且**还要通过二级索引回表**，那这种情况下优化器往往会觉得还不如直接顺序全表扫描，就不会用索引

所谓的边界值是跟统计信息、索引类型、是否覆盖索引以及磁盘 I/O 成本一起**综合的结果**，所以并没有一个固定的数值，实际中更多是通过**分析执行计划**来判断查询到底有没有走索引

#### 你在设计一张表的时候，会建哪些索引？为什么？

我一般会从以下三类索引去设计，InnoDB 也会自动建立主键索引、唯一索引（如果有唯一约束）和外键索引（如果没有索引会自动给外键列建索引，方便 JOIN）

**保证数据正确性的索引：主键索引、唯一索引**

绝大多数表我都会明确定义**主键**，用于唯一标识一行的同时方便 InnoDB 的聚簇索引按照主键组织整张表，让很多按照主键的点查和更新都非常高效

唯一索引则是用来**保证业务的唯一性**，同时兼顾性能，凡是业务上要求不能重复的字段都会优先用 UNIQUE 来实现，而不是只依赖代码逻辑检查

**支撑高频查询的索引：普通索引、联合索引（必要时前缀索引）**

普通索引经常出现在 where、order by、group by、join on 等子句中，但更多情况下不会只建一个单列索引，而是会根据查询的实际情况，设计联合索引，遵循最左前缀原则，把区分度高的字段放在前面

另外如果字段是**很长的字符串**，例如 url、邮箱等，我会考虑用前缀索引来节省空间，提高索引的缓存命中率

**特殊场景的索引：全文索引、空间索引**

如果需要对长本文做**关键词搜索**而不是精确匹配，我会考虑用全文索引来提升搜索效率，再就是对地理位置数据做空间查询时会用到空间索引

#### 你有用过联合索引吗，联合索引在匹配的时候要考虑什么？

有的，我在实际建表和调优里都会用到联合索引，联合索引在匹配时主要要考虑**最左前缀原则、查询/排序模式和列的选择性以及能不能做成覆盖索引**

联合索引本质上是**按照多列拼在一起建的一棵 B+ 树**，优化器在用它做索引查找时，只有从最左边开始连续命中的那几列才能被用到索引

如果使用了**范围查询**（比如 >、<、BETWEEN、LIKE 'prefix%' 等），或者 order by、group by 等**排序**操作，后续的列就无法再利用索引了

比如一个高频查询 SQL 是有 user_id、status、create_time 这三个字段，那我们就可以用 user_id、status 来过滤，然后用 create_time 来排序和 LIMIT，从而**避免分表**

#### 那比如说你要在一张表上去加一个索引，这个会比较快吗，还是其实挺慢的，你有没有试过，就是说加索引的这个动作本身，不是说加索引的效果，相当于对表结构做变更嘛，我需要加一个索引，这个操作的速度怎么样？

加索引这个动作相当于是**全表扫描一遍 + 按照这个索引重建一棵 B+ 树**，所以它的耗时是**取决于这张表的行数**的，如果是几万行的小表那感觉上会很快，但如果是几百万行的大表，那加索引的耗时就会比较明显

InnoDB 在加索引时会大概走下面的几步：

* 拿到**元数据锁**
  * 确保这张表的结构没有同时被别人修改，这一步会短暂阻塞其他 DDL
* 从聚簇索引把整张表扫一遍
  * 对每一行，取出要新建索引的列
  * 按照索引的列组合值插入到新的 B+ 树结构中
  * 即全表扫描 + 大量写索引页
* 做元数据切换，让新建的索引生效

#### 假如说现在有一个表它现在需要加索引，它加索引的耗时跟哪些因素有关系？跟硬件的哪些因素会有关系吗？比如说你加这个索引的时候你是在一台机器上加，机器它硬件有不同的规格，比如像你刚刚说的磁盘 I/O，如果它是高性能的固态硬盘，I/O 就快，那还有一些这个什么样的影响因素吗？

加索引相当于全表扫描 + 按索引重建一棵 B+ 树，它的耗时主要取决于**表本身和 MySQL 的运行环境**（配置 + 硬件），例如数据量、索引本身特性、当前读写并发和 MySQL 版本的 DDL 算法、磁盘 I/O、CPU 性能和内存大小/命中率等

* 表本身
  * **数据量**
    * 行数越多，要扫描的行越多，添加索引的耗时就越长
    * 行越宽（很多列、TEXT/JSON 大字段多），每一页能装的行就越少，要读写的页就越多
  * **索引本身的特性**
    * 联合索引的列越多，每条索引记录就越大，排序和写入的成本也就越高
    * 索引列的类型也会影响，比如字符串类型的索引记录通常比整数类型的更大
    * 如果是唯一索引，需要额外检查冲突，构建时也会多一些开销
  * **当前的读写并发**
    * 加索引的过程中 InnoDB 要扫描聚簇索引，对每一行插入新索引页
    * 如果是在业务低峰期添加索引的话，读写压力小，添加索引会更快
  * **MySQL 版本和 DDL 算法**
    * 不同版本的 MySQL 对 DDL 的支持和优化不一样
    * 老版本使用的是 COPY，会建临时表，拷贝所有数据，然后整体切换，很慢并且锁表时间长
    * 新版本支持 **INPLACE** 和 INSTANT，使用 INPLACE、LOCK=NONE 时，添加索引时不会阻塞 DML 操作，且不需要复制数据，直接在原表上原地地构建索引，可以降低锁表时间，但本质上还是要全表扫描和构建索引树
* 硬件
  * **磁盘类型和 I/O 能力**
    * HDD 的随机读写很慢，SSD 的随机 I/O 和 fsync 的延迟都小很多，建索引时间会明显缩短
    * 如果是远程云盘的话会多一层网络延迟的影响
  * **CPU 单核性能和核数**
    * 建索引过程中有大量的排序和页结构维护操作，CPU 性能越好，速度越快
    * 空闲核数越多，整体的耗时也会越短
  * **内存影响**
    * InnoDB Buffer Pool 如果足够大，就可以把大部分数据页和索引页都缓存到内存中，写索引时很多读写都能命中内存，可以减少磁盘 I/O
    * InnoDB 建立索引时还会用到排序缓冲和临时文件，sort_buffer_size 和 innodb_sort_buffer_size 越大，排序时就越多数据能放在内存中，减少磁盘临时文件的使用，从而提升建索引速度

#### 我们再把这个场景具象一些，就是比如说现在有一个线上运行的服务，然后它有一个表结构，现在它要做这个表结构变更，可能是加索引，可能是加字段，那为了避免说这个表结构的变更动作对现有业务产生影响，或尽量减少影响，你觉得有什么样的这个准备工作或策略？

我会先看一下这次具体要改的是什么，因为不同的表结构变更对业务的影响是不一样的，然后看一下表有多大、访问多频繁、当前 MySQL 支持的 DDL 算法是什么样的

如果这个服务本身就是**主从架构**，那我会选一台流量较少的**从库**，在这个从库上执行表结构变更，变更完成后确保这台从库和主库的数据结构保持一致，然后再把这台从库**提升为主库**，切换流量过去，最后再把原来的主库做成从库，等它同步完成后再作为备份

如果是**单体**，就要明确指定 **ALGORITHM=INPLACE, LOCK=NONE** 的 DDL 策略，然后选在业务低峰期执行变更，变更前后都要监控一下 MySQL 的性能指标，比如 CPU、磁盘 I/O、QPS、慢查询数量等，确保没有对业务造成影响

最后是**应用侧的兼容和回滚预案**，比如对于加字段、字段替代这种变更，我会先加字段，然后更新代码去同时写新旧字段、逐步迁移数据、切读流量，等确认没问题后再切换读新字段，最后再删掉旧字段，新索引加上去之后**执行计划也是有可能会变**的，然后如果真的出现了问题就回滚

#### DDL 是什么？比如说我们在加这个索引或者做别的 DDL 的时候，我们对现有业务可能带来什么样的风险呢？

**DDL（Data Definition Language）**是**数据定义语言**，主要用于**定义和修改数据库结构**，比如创建、修改、删除数据库、表、索引等

**DML（Data Manipulation Language）**是**数据操作语言**，主要用于**对数据库中的数据进行增删改查操作**

可以想象 DML 是在房间里搬东西，DDL 是改房子结构，MySQL 在执行 DDL 时，会对这张表加元数据锁，所以会**阻塞读写**，另外 DDL 操作本身也会消耗较多的系统资源（CPU、内存、磁盘 I/O），可能会影响到其他正常的 DML 操作，导致响应变慢，甚至超时失败

如果是**主库写、从库读**的场景，那在主库上执行一个 DDL 的时候，这条更改会记录到 binlog，然后从库会去重放这个 DDL 操作，如果从库的读流量比较大，那可能这个 DDL 还在被执行，业务以外读的是最新的数据，但实际上是**落后主库**的，并且执行期间其他的 SQL 重放也会被阻塞，如果有多个从库，那可能有的从库已经有新结构了，但有的还没有

再就是比如加了索引之后反而把**执行计划给变差了**，导致某些查询变慢了，或者新增/修改的某个字段不兼容现有的应用代码，我们这时应该**先只做兼容性的扩展**（加字段/索引，不立即删除旧字段），代码先双写或者兼容新旧两套，等确认没问题后再切换读新字段/索引，最后再删掉旧字段/索引

如果是**不支持 INPLACE** 的 DDL，那就会用 COPY 的方式，建一个临时表，拷贝数据，然后切换元数据，这个过程会锁表，阻塞所有的 DML 操作，可能会导致业务不可用

#### 那如果是主从同步的场景，这种表结构变更也需要在多个实例中去重复做吗？

最终效果上是主从结构里每个实例上，这张表都会完成一次 DDL，但**实际变更时通常只需要在主库执行一次 DDL**，主库会把这次 DDL 变更记录到 **binlog**，然后从库会**自动通过复制线程来拉 binlog 并按顺序重放这些 DDL 变更**，从而让从库的数据结构和主库保持一致

#### 如果是在从库执行这个 DDL，那这个从库不会有写到 binlog 然后其他实例自动通过复制线程来拉binlog然后顺序重放吗？如果是你刚刚说的把从库提升为主库然后切换流量那种情况，具体又会是什么样的？

在从库上执行 DDL，只要 b**inlog 是开启的**，那这个 DDL 就会**被写进从库自己的 binlog**，因为是本地执行的语句，和它重放主库过来的那些事件是分开的

如果主从的结构是**一主多从的星型结构**，那一个从库上手动执行的 DDL 是**不会**被传到其他从库的，**从库只会去看主库的 binlog**，而不会去看其他从库的 binlog

但如果是**级联的主从复制链**，比如一个主库 A 有自己的从库 B，然后 B 又有自己的从库 C，并且在 B 上配置了 **log_slave_updates = ON**，那当 B 在重放 A 的 binlog 时，会把这些事件写入自己的 binlog，C 从 B 拉取 binlog 并重放时就会看到 A 的 DDL 事件

我们这时在 B 上手动执行额外的 DDL，那这条语句也会被写进 B 的 binlog，然后 C 在拉取 B 的 binlog 时也会看到这条 DDL 事件并重放，这时 A 和 C 其实有同一条 DDL，但 **A 是完全不知道从库 B 的变更是什么的**

所以在实际的生产环境中**最好还是不要**在还在复制链里的从库上随便手动做 DDL，除非你非常清楚它会带来什么影响，一般都是只在主库上做 DDL，让它通过 binlog 自动同步到从库

如果是**在从库上做 DDL**，更多都是比如从线上某台从库拉取一份数据，然后**搭一台专门用于测试的从库**，可以有复制也可以没复制，但关键是要它是**不在业务的读写路径里**的，然后在这台演练库上执行 DDL，来看大概要跑多久、CPU/IO 抖动有多大、会不会有报错什么的，测试之后一般也不会再拿它直接接新流量，而是要么重建要么留着当以后别的的测试库

而**在从库上跑完 DDL 然后把它升级为主库**其实是一种比较激进的做法，流程是先从主库构建一台从库，在从库上执行 DDL，但执行过程中要**暂停从库的复制直到 DDL 跑完**，粗暴一点的做法就是这期间直接不管主库的写入，或者就是用一些在线的迁移工具，然后主库我们要找一个业务低峰期把它设置为只读，或者在应用层暂停对主库的写请求，然后**让从库追上主库的最新数据，就是把剩余的 binlog 补齐**，确定主从库的数据行内容都一致之后，再把从库提升为主库，切换应用流量过去，最后再把原来的主库做成从库，等它同步完成后再作为备份

如果在从库执行 DDL 时从库**还在持续拉取主库的 binlog 并重放**，由于这个 DDL 跟主库是不兼容的，所以会很容易导致复制线程报错然后挂掉，比如**主库在更新一个在从库上 DDL 要删掉或者修改类型的字段**

所以在实际操作中，这种先在从库修改结构然后再提升为主库的做法，一般都是**要么停止复制**，把原本的主库当作备份 + 补数据来用，**要么就是用一些在线的迁移工具**，比如 pt-online-schema-change、gh-ost 这种工具来做在线的表结构变更，这些工具会在后台悄悄地把数据迁移到一个新表上，然后再切换元数据，从而避免对主库造成太大影响

#### 诶那个表结构怎么逐步变更啊，它是一张表，它可以部分数据变部分数据不变吗？业务要部分停机吗？

在同一个实例的同一张表里，**不可能部分数据变部分数据不变**，因为表结构是针对整张表的，所有行都必须遵循同样的结构，只是 DDL 在执行过程中可能会有一个**短暂的不一致窗口期**，但最终结果是整张表都会变更成功

比如在加索引时，会全表扫描 + 重新构建 B+ 树，在这个过程中业务的读写是可以继续的，只有在**元数据切换**的那一瞬间会有一个短暂的锁表时间，之后所有行都会有这个新索引，或者使用了 **INSTANT** 的 DDL，比如加字段，这时**新字段会被加到表结构里**，但**所有现有行的这个新字段值都是 NULL**，只有在后续更新这些行时才会有具体的值，就是相当于**只改元数据**，直接让新字段生效，旧数据不会重写物理页，读取旧行时如果没有这个列的数据就按照默认值来处理

#### 能说一下 MySQL 在建立联合索引的一些注意事项吗，比如说索引的一些列有什么样的规则或规范，比如在建立联合索引时哪些列应该列入到联合索引里，哪些列又不应该列到联合索引里面？

**联合索引一定是围绕高频查询的 SQL 设计的**，常规的思路应该是，先找出这张表里最常用的几条 SQL，然后分析这些 SQL 里**哪些列经常一起出现在 where、order by、group by、join on** 这些子句里，再考虑用一棵 B+ 树尽可能同时服务这些查询

一般来说会把**选择性高、经常用来过滤的列**放在前面，要满足**最左前缀原则、等值查询在前范围查询在后、多个等值列之间再根据选择性和业务层级排序**，也可以考虑把需要的 select 放到联合索引里做成**覆盖索引**，但不会盲目塞很多大字段进去

相反，一些**选择性很差的字段**，比如性别、初中生年龄等，就不会让它们单独做索引或者放在联合索引的第一列，而是更多作为联合索引的后缀列，起到**辅助过**滤的作用，再就是**高频更新的字段**也不会放在联合索引里，因为这样的话索引的维护成本会比较高，另外像 TEXT/JSON 这种**大字段**也不会放在联合索引里，除非是用**前缀索引做搜索类场景**

#### 我建了五个列的联合索引，这样的联合索引对于我的读和写有哪些影响？

对于**读**来说，如果**这个联合索引和高频查询的模式贴得很紧**，比如前几列都是 where 里的**等值过滤**，最后一两列刚好用于**排序或分组**，甚至查询里也只用到了索引中的字段，那这棵多列索引可以同时承担**过滤、排序和覆盖索引**的作用，对于读性能的提升是非常明显的，但前提是查询必须满足**最左前缀原则**，能从索引的第一列开始连续命中，否则这棵联合索引就会失效

对于**写**的影响会更直接一点，所有的 insert、update、delete 都需要同时维护这棵比较胖的 B+ 树，插入时除了写聚簇索引，还要**把这五个字段组合成一个二级索引键插入索引页**，字段越多、索引记录越大，页分裂和 I/O 的概率就越高，如果更新语句改到了这五个字段中的任意一个，**实际上都是相当于在索引上做了 delete + insert 的操作**，所以在写多、历史数据多的表上，这种长联合索引的数量要控制，避免把一些频繁更新、选择性又不高的字段放进去，从而影响写性能

#### 联合索引建的太多对于写的影响是什么？

**对于 insert 的影响：**

每插入一条新记录时，InnoDB 不仅要把数据写入聚簇索引页，对于每个二级索引，还要拼出**索引键**、从根往下走找到插入位置、在叶子页插入，如果满了还可能**页分裂**

也就是说联合索引越多，**插入时要修改的 B+ 树也就越多**，键越大，单次插入写的数据也就越多、页分裂越频繁，导致插入的 QPS 上不去

**对于 update 的影响：**

只要更新的列在某个索引里出现过，那这个索引就必须要**先删掉旧的索引记录**，然后**再插入一条新的索引记录**，每次操作都可能引发**页分裂、redo 记录和 binlog 增加**，如果把**高频更新字段**放到了很多联合索引的前几列，那更新的开销会非常大，更新延迟边长并且热点行锁占用时间更久，更容易形成锁等待或者死锁

**对于 delete 的影响：**

跟 update 的影响类似，**先是聚簇索引删一次**，然后**每棵二级索引上都要删对应的索引记录**，联合索引越多，删除时要修改的 B+ 树也就越多，单次删除写的数据也就越多，导致删除的 QPS 上不去

**系统级的连锁影响：**

除了慢以外还会**拖累一切写相关的东西**，比如 **buffer pool** 被大索引挤占，真正的热点数据页和索引页被挤出去，导致**缓存命中率下降**，磁盘 I/O 增加

每次修改索引都要记入 redo log 和 binlog，**从库的复制延迟增加**，以及写一行数据的真实执行时间变长，导致**锁等待和死锁增加**，影响整体的并发能力

#### 我们在 MySQL 里面去创建一些数据库的话，为了提高数据库的查询效率，一般我们会去创建索引，那在创建索引时需要注意什么？

首先我们应该**从查询触发而不是从字段出发**，先看这张表的高频 SQL，where、join、order by、group by 这些子句都是怎么写的，再**围绕这些访问模式去设计索引**，而不是看见哪个字段重要就给哪个字段建索引

其次是**在选列和顺序上要注意字段的选择性和最左前缀原则**，优先把选择性高、过滤能力强、经常出现在 where 或 join 里的字段放在联合索引的前面，把范围条件和排序字段放在后面，让一棵索引既能过滤又能排序，必要时还可以做成**覆盖索引**，像是性别和布尔状态这种低选择性字段一般都只放在联合索引的**末尾**，而不是单独建索引

再次是要**控制索引的数量和宽度**，因为每多一个索引，insert/update/delete 就要多维护一棵 B+ 树，写放大会明显增加，redo log 和 binlog 的体积也会变大，主从复制容易延迟，应当定期**清理掉没用的索引**，合并功能重复的索引，避免把**高频更新的字段**放到索引里，另外对于一些大字符串字段，可以考虑用**前缀索引**来节省空间，提高缓存命中率

最后，我们应该**回到 SQL 本身**，SQL 的写法应当**配合建好的索引**，尽量避免在索引列上**套函数**、避免**前置模糊匹配**、必要时使用 explain / explain analyze 来分析执行计划，确保查询能走上索引，从而发挥索引的作用，如果是大表加索引这种 DDL，要当成是一次**有风险的变更**，要先在测试或从库上演练，线上选在业务低峰期执行，并且做好监控和回滚预案

#### 创建索引时我们的匹配原则应该是什么样的，是左前缀还是右前缀？

无论是联合索引还是字符串前缀索引，本质上都是**左前缀原则**，B+ 树和比较规则都是从左到右的

**联合索引**的左前缀原则是指**从联合索引的第一列开始，必须连续命中左边的列**，才能利用这个索引进行查找，否则索引就会失效

**字符串的前缀索引**左前缀原则是指**只能从字符串的开头开始匹配**，如果是 like 查询的话，只能用 **'prefix%'** 这种形式，不能用 '%suffix' 或者 '%middle%' 这种形式，否则索引就会失效

#### 如果我对某个字段做了索引，那索引列它能参与计算或者函数操作吗？

**索引列当然可以参与计算和参数操作**，但如果在 where 里把索引列写成**被包在函数或表达式左侧**，那通常会让 B+ 树没办法用有序性来做快速查找，从而导致**索引失效**

**在索引列上做函数：**

```sql
WHERE DATE(created_at) = '2025-01-01'
WHERE LOWER(email) = 'abc@test.com'
WHERE FROM_UNIXTIME(ts) > '2025-01-01 00:00:00'

-- 正确写法
-- 替代 DATE(created_at) = '2025-01-01'
WHERE created_at >= '2025-01-01 00:00:00'
  AND created_at <  '2025-01-02 00:00:00'

-- 替代 LOWER(email) = 'abc@test.com'
WHERE email = 'abc@test.com'  -- 或存储时统一小写
```

**把列放进算式左边：**

```sql
WHERE age + 1 > 18
WHERE price * 1.2 < 100
WHERE (score / 10) >= 6

-- 正确写法
WHERE age > 17
WHERE price < 100 / 1.2
WHERE score >= 60
```

**或常量有简单计算，但都在右边，此时不会导致索引失效：**

```sql
-- 正确写法
WHERE age > (18 - 1)
WHERE price < (100 / 1.2)
WHERE score >= (60 * 10)
```

**在 LIKE 前面加百分号：**

```sql
WHERE name LIKE '%Ethan'    -- % 开头
WHERE name LIKE '%Ethan%'

-- 正确写法
WHERE name LIKE 'Ethan%'    -- 只能前缀匹配
```

如果业务上确实大量用到某个表达式，比如 **LOWER(email) 或 DATE(created_at)**，那可以考虑**把表达式的结果单独存一列**，然后**给这列建索引**，从而避免在查询时对索引列做函数或计算，本质上底层是用索引去查新生成的计算结果列

```sql
WHERE DATE(created_at) = '2025-01-01'

-- 改为
ALTER TABLE orders
  ADD COLUMN create_date DATE
    GENERATED ALWAYS AS (DATE(created_at)) STORED,
  ADD INDEX idx_create_date (create_date);
WHERE created_date = '2025-01-01'  -- created_date 是单独存储日期部分的列
```

**或者是建立表达式索引：**

```sql
CREATE INDEX idx_lower_email ON users ((LOWER(email)));

SELECT * FROM users
WHERE LOWER(email) = 'abc@test.com';
```

这时是可以用到这个**表达式索引**的，这个索引是**建立在函数表达式上的，而不是原始列上**

#### 索引的优缺点有哪些？

* **优点**
  * **大幅提升查询效率**
    * 如果没有索引，MySQL 只能通过**全表扫描**来查找数据
    * 有索引之后，可以在一棵有序的 B+ 树上做二分 + 范围查找，极大减少需要访问的行数和页数
  * **提升排序、分组、关联的性能**
    * 索引本身是有序的，可以直接利用索引的顺序来做 order by、group by 和 join 操作，避免额外的排序和临时表开销
  * **支持数据的唯一性约束**
    * 能在插入或更新数据时检查是否有重复数据，省去了应用层手工查重的大量查询
  * **覆盖索引**
    * 只通过索引就能满足查询，避免回表，进一步提升查询性能
* **缺点**
  * **增加写操作的开销**
    * 每次 insert、update、delete 都需要维护索引，插入新记录时要在索引页插入新键，更新索引列时要删除旧键再插入新键，删除记录时也要删除对应的索引键
    * 索引越多、越宽，维护成本越高，写操作的延迟和资源消耗也就越大
  * **占用存储空间**
    * 每个索引都要单独占用磁盘空间
    * buffer pool 里要缓存索引页和数据页，索引太大会挤占数据页缓存，降低缓存命中率，更容易落到磁盘 I/O
  * **可能导致执行计划变差**
    * 如果索引设计不合理，或者查询写法不当，可能会导致优化器选择了一个不合适的索引，反而让查询变慢
    * 例如低选择性字段单独建索引，或者在索引列上套函数、前置模糊匹配，或者联合索引顺序不对，左前缀命中不了
  * **索引本身的变更是重操作**
    * 添加索引的本质是全表扫描 + 建一棵新的 B+ 树
    * 如果没有使用 INPLACE 或 INSTANT 的 DDL，可能会锁表，阻塞读写，影响业务可用性

#### 


