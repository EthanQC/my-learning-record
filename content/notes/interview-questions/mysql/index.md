## 索引
#### 什么是索引？

索引是**帮助存储引擎快速获取数据的一种数据结构**，索引就是数据的目录

索引和数据一样，都位于存储引擎中

#### 索引有哪几种？
**一个索引是可以同时属于好几类的**，比如主键索引既是 B+ 树索引，又是聚簇索引，通常又是一个联合索引或单列索引

* 按数据结构：
  * **B+ 树索引**
    * 基于 **B+ 树**的索引结构，**所有的数据（或主键）都出现在叶子节点，非叶子节点只存索引键 + 指针**
    * 叶子节点里的数据是**按照主键顺序**存放的
    * 叶子节点之间是**双向链表**，层高一般很**低**，三到四层就可以覆盖几百万行，I/O 次数少，范围查询效率高
  * **哈希索引**
    * 用一个**哈希函数**把索引列映射到哈希表的桶里，查找是算哈希值、定位桶，然后在桶里线性查找
    * **只适合等值查询，不支持范围查询**，因为哈希之后是没有顺序概念的，且哈希冲突会影响性能
    * 本质上是一张哈希表，MEMORY 引擎支持显式哈希索引，InnoDB 更多是内部通过**自适应哈希索引**来加速热点数据访问，它会在内存里对热点页自动建一层哈希来加速访问，但是是**没办法手动创建**的
  * **全文索引**
    * 主要用于**长文本**的搜索，底层是**倒排索引**，是**把词项映射到包含这个词的文档或行列表**
    * 可以做分词和相关性排序，适合做某个字符串是否出现在文本中这种**模糊查询**
* 按物理存储：
  * **聚簇索引（主键索引）**
    * 数据本身**按索引 key 的顺序存储**，表数据**按照主键的顺序**存储在 B+ 树的**叶子节点**上，叶子节点存的是**完整的行数据**
    * 也就是说 InnoDB 的**数据文件本身就是一个按主键排序的 B+ 树**，非叶子节点记录主键值和指针，叶子节点存完整行数据，**这棵树就是聚簇索引**
    * **一张表只能有一个聚簇索引**，最好用**自增整型**来做主键，避免频繁页分裂
  * **二级索引（辅助索引）**
    * 除了聚簇索引**以外**的其他 B+ 树索引都是二级索引，**叶子节点存的是索引列 + 主键列**
    * 查二级索引时，**先在二级索引树上定位到叶子节点，然后通过主键回聚簇索引查完整行数据**，也就是要查找两个 B+ 树才能找到数据，这被称为**回表**
    * 一张表可以有**多个**二级索引
  * **覆盖索引**
    * 在二级索引的基础上，**能在二级索引的 B+ 树就能满足查询所需的所有列**，相当于索引包含了要查询的值，就不需要回表查聚簇索引
    * 这样查询**只需要访问二级索引树**，减少了 I/O 次数，提升查询性能
* 按字段特性：
  * **主键索引**（默认使用 B+ 树）
    * `PRIMARY KEY (index_column_1)`
    * **唯一标识一行数据，不能为空**，在 InnoDB 中主键索引就是聚簇索引
    * **一张表只能有一个主键**，一旦确定就不应该频繁修改
  * **唯一索引**
    * `UNIQUE KEY(index_column_1,index_column_2,...)`
    * `CREATE UNIQUE INDEX index_name ON table_name (index_column_1, index_column_2, ...);`
    * 确保某一列或某些列的组合值在表内**不重复**
    * **允许有 NULL 值**，但多个 NULL 被认为是不重复的
    * 同一张表可以有**多个**唯一索引，底层一般也是用 B+ 树实现
    * 适合用于用户手机号、邮箱、身份证号等天然唯一的字段
  * **普通索引**
    * `INDEX(index_column_1,index_column_2,...)`
    * `CREATE INDEX index_name ON table_name (index_column_1, index_column_2, ...);`
    * 最普通的一种索引，只负责加速查询，不保证唯一性
    * **可以有重复值和 NULL 值**
  * **前缀索引**
    * `CREATE TABLE table_name(column_list, INDEX(column_name(length)));`
    * `CREATE INDEX index_name ON table_name (column_name(length));`
    * 对**字符型字段**，如 CHAR、VARCHAR、TEXT，**只取前 N 个字符建立索引**，而不是整个列
    * 可以节省存储空间和内存，但会降低索引的选择性，不能保证真正唯一
    * 在 select 需要完整值时，仍然需要回表查询完整数据
    * 只能保证**前缀范围内**有序，不支持后续字符的排序和范围查询
* 按字段个数：
  * **单列索引**
    * 只包含一个列的索引
    * 适合单字段查询频繁的场景
  * **联合索引（复合索引）**
    * `CREATE INDEX index_product_no_name ON products (product_no, product_name);`
    * 索引 key 同时包含**多个列**，B+ 树是**按照这些列的组合值从左到右排序的**，可以多个前缀，也可以部分列
    * 在建立联合索引时，要**把区分度大的字段排在前面**，提高索引的选择性
    * 遵循**最左前缀原则**，查询条件必须从最左边的列开始才能使用索引，不符合最左前缀之所以会失效是因为**索引树是按列的组合值排序的**，跳过最左边的列就无法利用索引的有序性，**利用索引的前提是索引里的 key 是有序的**
    * 并且**只有等值条件才能继续往后匹配**，遇到**范围查询**则在范围查询字段后面的字段是无法利用联合索引的，因为只有最左边的的列是有序的，右边的字段的值在范围内是无序的
    * 但如果是 `select * from t_table where a >= 1 and b = 2` 这样的**大于等于**的范围查询，虽然在符合 `a >= 1` 条件的二级索引记录的范围里，b 字段的值是无序的，但是对于**符合 `a = 1` 的二级索引记录的范围里**，b 字段的值是**有序**的（先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序），所以这条查询语句 a 和 b 字段都用到了联合索引进行索引查询
    * 如果是 `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，由于在 MySQL 中的 BETWEEN 是**包含边界值**的，所以这条查询语句 a 和 b 字段都用到了联合索引进行索引查询
    * 如果是 `SELECT * FROM t_user WHERE name like 'j%' and age = 22`，在符合前缀为 'j' 的 name 字段的二级索引记录的范围内，age 字段的值是无序的，但是对于符合 `name = 'j'` 的二级索引记录的范围里，age 字段的值是有序的（先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序），所以在确定需要扫描的二级索引的范围时，**可以通过 age 字段来进一步缩小范围**，所以这条查询语句 name 和 age 字段都用到了联合索引进行索引查询
    * 综上，联合索引的**最左匹配（前缀）原则**在遇到**大于或小于**时，只有使用了范围查询的字段可以用到联合索引，其后面的字段是用不到的
    * 但如果是**大于等于、小于等于、BETWEEN 或 like 前缀匹配**的范围查询时，联合索引是会生效的
    * 在联合索引的 B+ 树中找到第一个满足条件的主键值之后，后续判断其他条件时是可以**在联合索引遍历过程中就直接判断**，过滤掉不满足条件的记录，而不是回到主键索引中判断，从而减少回表次数，这被称为**索引下推**，执行计划里出现了 **Extra** 为 **Using index condition** 时就说明启用了索引下推优化

#### 针对下面这条 SQL，怎么通过索引来提高查询效率？`select * from order where status = 1 order by create_time asc`



#### MySQL为什么使用B+树来作索引？
说一下索引失效的场景？

**Q：建立索引要注意哪些问题**

A：首先是要明确好热点查询，只针对真正会用到且查询频率高的字段建立索引，避免过多的索引导致性能下降；其次是要考虑索引的选择性，选择性越高的字段越适合做索引，选择性低的字段做索引反而会降低性能；另外是要考虑索引的存储空间和维护成本，索引会占用额外的存储空间，并且在数据更新时也需要维护索引，所以要权衡好性能和存储空间之间的关系；最后是要定期检查和优化索引，删除不必要的索引，避免冗余和重复的索引

**Q：性别和年龄要不要建立索引，以及记录的如果是初中生的年龄，还要不要建立索引**

A：其实都没什么必要，因为性别和年龄的选择性都比较低，性别只有男和女两个值，年龄也只有特定数量的值，所以做索引的话反而会增加存储空间和维护成本，而且查询性能提升也不明显；如果是初中生的年龄，那就更没必要了，因为初中生的年龄范围也就 12 到 15 岁，只有四个值，做索引的话反而会降低性能，因为索引页命中后还要回表，除非是业务确实有这个需求，那可以把年龄放到联合索引的末尾，但其实这样也不会提升特别多性能，不如用缓存或者分区表来优化

**Q：是不是有索引就一定会走，优化器选择走索引的边界值是多少**

A：不是的，是否走索引是由优化器的代价比较决定的，优化器会估算全表扫描的顺序读成本和索引查找 + 回表的随机读成本，然后选择代价更低的方案；边界值的话其实并不是固定的，常用的经验法则是当索引筛出的行数小于总行数的 3% - 5% 时索引扫描通常更优，否则全表扫描更划算，但这也不是绝对的，因为有很多参数都影响着优化器的选择，在实际开发中可以使用 explain 和 analyze 来观察优化器行为来判断是否使用了索引



**Q：MySQL 建表会使用到哪些索引**

A：在建表时我会先给表定义一个自增主键做聚簇索引，保证行存和主键一致，如果业务需要保证某列数据唯一，就加唯一索引，对于常用的过滤和连接字段，我会建普通索引来防止全表扫描，如果多个字段经常一起作为条件，我会用最左前缀建立联合索引，并尽量做覆盖索引来减少回表；如果有大文本字段需要做全文检索，我会使用全文索引来加速查询

**Q：联合索引在匹配的时候要考虑什么**

A：首先要遵循最左前缀原则，查询必须从最左边的字段开始才能使用索引，并且只有等值条件才能继续往后匹配，遇到范围查询则会截止，另外要把选择性高的列放在最前面，避免在索引列上使用函数或隐式转换，否则都会导致不能走索引，如果要进一步提高性能，可以设计成覆盖索引，让查询完全在索引层面完成而不用回表

* 有用过联合索引吗，就是多个字段建一个索引

* 那比如说你要在一张表上去加一个索引，这个会比较快吗，还是其实挺慢的，你有没有试过，就是说加索引的这个动作本身，不是说加索引的效果，相当于对表结构做变更嘛，我需要加一个索引

* 假如说现在有一个表它现在需要加索引，它加索引的耗时跟哪些因素有关系？跟硬件的哪些因素会有关系吗？比如说你加这个索引的时候你是在一台机器上加，机器它硬件有不同的规格，比如像你刚刚说的磁盘 I/O，如果它是高性能的固态硬盘，I/O 就快，那还有一些这个什么样的影响因素吗？

* 我们再把这个场景具象一些，就是比如说现在有一个线上运行的服务，然后它有一个表结构，现在它要做这个表结构变更，可能是加索引，可能是加字段，那为了避免说这个表结构的变更动作对现有业务产生影响，或尽量减少影响，你觉得有什么样的这个准备工作或策略

* 诶那个表结构怎么逐步变更啊，它是一张表，它可以部分数据变部分数据不变吗？

* 比如说我们在加这个索引或者做别的 DDL 的时候，我们对现有业务可能带来什么样的风险呢？

* 你说的从表是说有两个实例在做主从同步是吧，还是怎么样

* 那如果是主从同步的场景，这种表结构变更也需要在多个实例中去重复做吗？

* 主从同步的机制是什么样的？是哪些操作会同步哪些操作不会同步？

* 我说的不是同步策略，我说的是机制是什么样的，比如你说的主从同步是说我们要靠运维主动去做一个这样的数据同步的脚本还是说 MySQL 自己有一些同步的机制

* 具体是用哪条命令来看索引有没有命中

* 能说一下 MySQL 在建立联合索引的一些注意事项吗，比如说索引的一些列有什么样的规则或规范，比如在建立联合索引时哪些列应该列入到联合索引里，哪些列又不应该列到联合索引里面

* 我建了五个列的联合索引，这样的联合索引对于我的读和写有哪些影响

* 联合索引建的太多对于写的影响是什么

* 我们在 MySQL 里面去创建一些数据库的话，为了提高数据库的查询效率，一般我们会去创建索引，那在创建索引时需要注意什么

* 创建索引时我们的匹配原则应该是什么样的，是左前缀还是右前缀

* 如果我对某个字段做了索引，那索引列它能参与计算或者函数操作吗

* 索引的优缺点有什么，索引的类型有哪些

* 什么样的场景索引会失效