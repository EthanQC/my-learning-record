## 日志
#### undo log、redo log 和 binlog 分别是什么？

**undo log（回滚日志）**是 InnoDB 存储引擎层生成的日志，实现了事务中的**原子性**，主要用于**事务回滚和 MVCC**

**redo log（重做日志）**也是 InnoDB 存储引擎层生成的日志，实现了事务中的**持久性**，主要用于**掉电**等故障恢复

**binlog（归档日志）**是 server 层生成的日志，主要用于**数据备份和主从复制**

#### 为什么需要 undo log？

我们在执行增删改的语句时，mysql 会**隐式自动开启事务**来执行，执行完毕就自动提交，如果这个事务在执行过程中，MySQL 发生了**崩溃**，就需要使用 **undo log** 来**回滚**到事务之前的数据，事务的**原子性**就是这样实现的

**undo log 是一种用于撤销回退的日志**，在事务没提交之前，MySQL 会记录更新前的数据到 undo log 中，比如在插入一条记录时，会把这条记录的主键值记下来，回滚时只要把这个主键值对应的记录删掉就好了，删除和更新也是同理，都是**做原先的相反操作**，但 delete 其实不会立即删除，而是将要被删除的对象打上 delete flag，标记为删除，最终由 purge 线程完成删除，update 就要看更新的列是否是主键列，不是的话就在 undo log 中直接反响记录是如何 update 的，是的话就先删除该行，再插入一条目标行，**不同的操作需要记录的内容是不同的，对应所产生的 undo log 的格式也是不同的**

undo log 的另外一个作用是**配合 ReadView 实现 MVCC（多版本并发控制）**，一条记录的每一次更新操作产生的 undo log 的格式都有一个 **roll_pointer 指针和一个 trx_id 事务 id**，roll_pointer 可以**将这些不同版本的 undo log 串成一个链表**，这个链表就被称为**版本链**，trx_id 可以**标识该记录是被哪个事务修改的**

对于**读已提交**隔离级别来说，它是**每个 select 都会生成一个新的 ReadView**，也就是说事务期间多次读取同一条数据，前后两次读到的数据可能会出现不一致，对于**可重复读**隔离级别来说，它只会**在事务开始时生成一个 ReadView**，然后整个事务期间都用这个 ReadView，事务期间多次读取同一条数据，前后两次读到的数据是一致的

这两个隔离级别都是通过 **MVCC** 实现的，也就是**快照读**，它们会根据事务的 ReadView 里的字段和记录中的 trx_id 和 roll_pointer 这两个隐藏字段来**判断该记录的版本是否对当前事务可见**，如果不可见，就通过 roll_pointer 指针顺着 undo log 版本链找到对应的 undo log，然后根据 undo log 里的内容来还原出该记录对当前事务可见的版本

所以，undo log 就是**实现事务回滚**，保障事务的原子性，和**配合 ReadView 实现 MVCC**，这两个主要的功能，undo log 和数据页的刷盘策略是一样的，都要**通过 redo log 来保证持久化**，buffer pool 中有 undo 页，对 undo 页的修改也会记录到 redo log，redo log 会每秒刷盘，提交事务时也会刷盘，从而保证持久化

#### 为什么需要 redo log？


