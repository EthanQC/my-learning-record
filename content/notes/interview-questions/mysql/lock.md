## 锁
#### MySQL 有哪些锁？

根据加锁的范围，可以分为**全局锁、表级锁和行锁**三种

**全局锁：**

使用 **`FLUSH TABLES WITH READ LOCK`** 语句可以**对整个数据库实例加全局读锁**，执行后，整个数据库就处于**只读状态**了，如果要释放全局锁则要执行 **`UNLOCK TABLES`** 语句，**在会话断开时全局锁也会被自动释放**

全局锁主要应用于做**全库的逻辑备份**，这样在备份期间就不会因为数据或表结构的更新而导致备份文件的数据与预期的不一致

如果数据库里有很多数据，备份就会花费很多时间，导致业务停滞，但如果开启了**可重复读隔离级别**的事务，那在备份之前先开启事务，这样由于**整个事务执行期间**用的都是这个 Read View，在 MVCC 的支持下，备份期间业务依然可以对数据进行更新操作，因为即使其他事务更新了表的数据，当前事务依然可以读取到事务开始时的数据快照，这就是事务四大特性中的**隔离性**，这样就不用使用全局锁了

备份数据库的工具是 mysqldump，使用时加上 `--single-transaction` 参数即可开启一个事务来进行备份，但只适用于支持可重复读隔离级别的存储引擎，比如 InnoDB

**表级锁：**

* **表锁**
  * **读锁**
    * 表级别的**共享锁**，允许当前会话读取表中的数据，但**不允许其他会话对表进行写操作**
    * `LOCK TABLES table_name READ;`
  * **写锁**
    * 表级别的**排他锁**，允许当前会话对表进行读写操作，但**不允许其他会话对表进行任何读写操作**
    * `LOCK TABLES table_name WRITE;`
  * 表锁除了会限制别的线程的读写外，**也会限制当前线程接下来的读写操作**
  * 例如，在某个线程中执行了 `lock tables t1 read, t2 write;` 之后，其他线程写 t1、读写 t2 的语句都会被阻塞，并且，当前线程只能对 t1 执行读操作，对 t2 执行读写操作，不能对 t1 执行写操作，直到执行 `unlock tables;` 释放锁
  * 在释放锁之前，当前线程也不能访问其他表
  * 当会话退出后，也会释放所有表锁
  * 在还没有出现更细粒度的锁时，表锁就是最常用的处理并发的方式
* **元数据锁（MDL，Metadata Lock）**
  * 不需要显式使用，当我们对数据库表进行操作时，MySQL 会**自动**为表加上元数据锁
    * 对一张表进行 **CRUD** 时，加的是 **MDL 读锁**
    * 对一张表进行 **DDL** 操作时，加的是 **MDL 写锁**
  * 当有线程在执行 CRUD 时，如果其他线程想对该表进行 DDL 操作，就会被阻塞，如果执行的是 DDL 操作，其他线程想对该表进行 CRUD 操作也会被阻塞
    * 但是多个线程同时执行 CRUD 操作时，是不会互相阻塞的
  * MDL 在事务提交后才会释放，也就是说在事务执行期间，MDL 是一直持有的
    * 如果线程 A 先启用了事务，但是一直不提交，它执行了一条 select 语句，就会先对该表加上 MDL 读锁
    * 然后线程 B 也执行了同样的 select 语句，这时线程 B 不会被阻塞，因为 **MDL 读锁是可以共享**的，也就是**读读并不冲突**
    * 然后线程 C 修改了表字段，但由于 A 的事务还没有提交，也就是 MDL 读锁还没有释放，所以线程 C 申请不到 MDL 写锁，就会被阻塞
    * 此时在 C 阻塞后，后续所有对该表的 select 语句也会被阻塞，因为所有申请 MDL 锁的操作会形成一个队列，队列中**写锁的获取优先级是高于读锁**的
* **意向锁**
  * 在使用 InnoDB 引擎的表里对某些记录加上共享锁之前，要先在表级别加上一个**意向共享锁**
  * 独占锁也是同理，在对某些记录加上独占锁之前，要先在表级别加上一个**意向独占锁**
  * 意向共享锁和意向独占锁是表级锁，**不会和行级的共享锁和独占锁冲突**，**意向锁之间也不会发生冲突**，只会和共享表锁和独占表锁冲突
  * 表锁和行锁是满足读读共享、读写互斥、写写互斥的
  * 如果没有意向锁，那在加独占表锁时，就需要**遍历整张表的所有记录**，查看是否有行锁存在，这样会非常低效，而有了意向锁后，只需要查看表级别的意向锁就可以知道是否有行锁存在，从而提高了加锁的效率
* **AUTO-INC 锁**
  * 一张表里的主键通常都会设置成**自增**的，是通过对主键字段声明 `AUTO_INCREMENT` 来实现的，之后插入数据时就可以不用指定主键的值，数据库会自动给主键赋递增的值，这就是通过 AUTO-INC 锁来实现的
  * AUTO-INC 锁是一种**表级的特殊锁**，它不是在一个事务提交后才释放，而是**在执行完插入语句之后就会释放**，在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 `AUTO_INCREMENT` 声明的字段生成下一个自增值，最后释放锁
  * 也就是说，一个事务在持有 AUTO-INC 锁的过程中，其他事务如果要向该表插入语句，就会被**阻塞**，直到 AUTO-INC 锁被释放，从而保证插入数据时，被 `AUTO_INCREMENT` 声明的字段生成的值是唯一且连续递增的
  * 但这样如果在大量数据插入的场景下，是会影响性能的，因此 InnoDB 提供了一种**轻量级的锁**来实现自增，也是同样在插入数据时为被 `AUTO_INCREMENT` 声明的字段加上轻量级锁，然后赋一个自增的值，然后就释放锁，而**不需要等待整个插入语句执行完毕才释放锁**
  * InnoDB 提供了 **`innodb_autoinc_lock_mode`** 的系统变量
    * `innodb_autoinc_lock_mode=0`：传统锁模式，使用表级的 AUTO-INC 锁，语句执行结束后才释放锁
    * `innodb_autoinc_lock_mode=1`：普通的 insert 语句使用轻量级锁，批量插入语句还是使用表级的 AUTO-INC 锁
    * `innodb_autoinc_lock_mode=2`：所有插入语句都使用轻量级锁
  * 使用 `innodb_autoinc_lock_mode=2` 是性能最高的方式，但当搭配 **binlog 的日志格式是 statement** 一起使用时，在**主从复制**的场景下会发生**数据不一致**的问题
    * 例如，A 往表里插入了四条数据，生成的自增主键分别是 1、2、3、4，然后 B 建了一个相同结构的表，现在 A 和 B 同时往这个新的表中插入数据，B 先插入了两条数据，生成的自增主键是 1、2，然后 A 申请自增 id 得到 id = 3，插入了这条数据，接着 B 又插入了两条数据，生成的自增主键是 4、5，这时 B 的insert 语句生成的 id 是**不连续**的
    * 而主库发生这种情况时，binlog 面对第二张表的更新，只会记录这两个 session 各自的 insert 语句，在 `binlog_format=statement` 的情况下，记录的就是**原始语句**，顺序要么先是 A 的 insert，要么是 B 的 insert
    * 但无论是哪一种，在 binlog 拿去从库执行时，**从库是按照顺序执行语句的**，因此在从库上是不会有像主库那样 A 和 B 同时执行向第二张表插入数据的场景的，所以在从库上执行了 B 的 insert 语句，生成结果中，自增主键分别是 1、2、3、4，而不是主库上的 1、2、4、5，这样就导致了**主从数据不一致**的问题
    * 要解决这个问题，**binlog 的日志格式要改成 row**，这样在 binlog 里记录的就是**主库分配的自增值**，这样既能提升并发性，又不会出现数据一致性的问题

**行级锁：**

InnoDB 存储引擎支持行级锁，MyISAM 存储引擎不支持行级锁，普通的 select 语句是不会对记录加锁的，因为它属于**快照读**，如果是 `select ... for update` 或者 `select ... lock in share mode` 语句，则会对读取到的记录分别加上**行级的独占锁和共享锁**，但这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，也就是说必须配合 `begin`、`start transaction`、`set autocommit = 0` 和 `commit` 等语句一起使用

在**读已提交**隔离级别下，行级锁只有记录锁，而在**可重复读**隔离级别下，行级锁有记录锁、间隙锁、临键锁和插入意向锁四种

**共享锁（S 锁）满足读读共享，独占锁（X 锁）满足读写互斥和写写互斥**，行级锁主要有以下几种：

* **Record Lock（记录锁）**
  * 记录锁只能放在**已经存在**的记录上
  * 记录锁是有 S 锁和 X 锁之分的，**S 锁和 S 锁是兼容的，X 锁和 X 锁不兼容，S 锁和 X 锁也不兼容**
  * `select * from t_test where id = 1 for update;` 这条语句就是对 id = 1 的记录加上了 X 锁
* **Gap Lock（间隙锁）**
  * 间隙锁存在于**可重复读隔离级别和串行化隔离级别**，目的是为了解决可重复读隔离级别下的**幻读**问题
  * 例如，表中有一个范围 id 是 `(3, 5)` 的间隙锁，那其他事务就无法插入 id = 4 的记录了
  * 间隙锁虽然存在 S 型和 X 型之分，但它们之间是没有区别的，**间隙锁之间是兼容的**，也就是说两个事务是可以同时持有包含共同间隙范围的间隙锁
* **Next-Key Lock（临键锁）**
  * 临键锁是**记录锁和间隙锁的组合**，锁定一个范围的同时锁定记录本身
  * 例如，表中有一个范围 id 是 `(3, 5]` 的临键锁，那其他事务无法插入 id = 4 的记录，也无法修改 id = 5 的记录
  * 如果一个事务获取了 X 型的临键锁，那么另外一个事务在获取相同范围的 X 型临键锁时，是会**被阻塞**的
  * 这是因为虽然相同范围的间隙锁是多个事务相互兼容的，但**对于记录锁，X 锁和 X 锁之间是不兼容的**
* **Insert Intention Lock（插入意向锁）**
  * 一个事务在插入一条记录时，需要判断插入的位置**是否已经被其他事务加了间隙锁**（临键锁也包括间隙锁），如果有的话，就会被阻塞，直到拥有间隙锁的那个事务提交为止
  * 在此期间，就会生成一个**插入意向锁**（此时这个锁并不是真正持有的，它只是一个锁请求，由于此时那个间隙锁还存在，所以这里就是**等待状态的锁**），表明有事务想在某个区间插入新纪录，但现在处于等待状态
  * MySQL 在加锁时，是先生成锁结构，然后设置锁的状态，如果锁是等待状态，并不代表事务成功获取到了锁，只有当锁状态是**正常状态时**，才表示事务成功获取到了锁
  * 插入意向锁虽然名字有意向锁，但它并不是意向锁，它**是一种特殊的间隙锁**，属于行级别锁
  * 如果说间隙锁锁住的是一个区间，那插入意向锁锁住的就是**一个点**，但尽管插入意向锁也属于间隙锁，但**两个事务是不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁的**，此时另一个事务的插入意向锁请求会被阻塞，相当于拿到的是**等待状态**的锁
  * 只有在间隙锁释放之后，插入意向锁才能变成**正常状态**的锁，从而成功插入记录，插入意向锁表示的是**要对这个区间的某个位置进行插入操作的意图**，多个插入意向锁之间通常是**兼容**的，只有在这条新纪录被插入产生后，才会有这条记录的记录锁，插入意向锁说是锁住某个点，但它并不是记录锁

#### 什么 SQL 语句会加行级锁？

普通的 select 语句是不会加行级锁的，因为它属于**快照读**，如果是 `select ... for update` 或者 `select ... lock in share mode` 语句，则会对读取到的记录分别加上**行级的独占锁和共享锁**，但这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，也就是说必须配合 `begin`、`start transaction`、`set autocommit = 0` 和 `commit` 等语句一起使用

另外，**update 和 delete** 操作都会加行级锁，并且锁的类型都是**独占锁**

共享锁满足读读共享、读写互斥，独占锁满足写写互斥、读写互斥

#### MySQL 是怎么加行级锁的？

**加锁的对象是索引，基本单位是临键锁**，**临键锁**是**左开右闭**区间，**间隙锁**是**左开右开**区间，在能使用记录锁或者间隙锁就能避免幻读现象的场景下，临键锁会退化成记录锁或间隙锁

**唯一索引等值查询：**

当我们在用唯一索引进行等值查询时，如果**查询的记录是存在的**，并且**是主键索引**的情况下，加的就是 **X 型的记录锁**，只加在主键索引上，会阻塞其他对这个索引进行更新或删除的操作，因为更新或删除操作也会对记录加 X 型的记录锁，如果是**二级索引** + 唯一索引，那除了会**对二级索引加行级锁**以外，还会**对查询到的记录对应的主键索引加上记录锁**

如果查询的记录**不存在**（还是主键索引），此时加的就是 **X 型的间隙锁**，锁定的是这个记录所在的间隙范围，如果有其他事务想插入中间主键值的记录，就会被阻塞，但如果是插入边界值的主键记录，则不会被阻塞，而是报**主键冲突**的错误，因为左右边界值的记录已经存在了，间隙锁的范围是**在索引树找到第一条大于等于该查询记录的记录后，再找到它的前一条记录，然后锁定这两条记录之间的间隙范围**

之所以只需要加记录锁和间隙锁，是因为在唯一索引 + 等值查询的场景下，**只使用这两种锁，就不会出现幻读的问题**，在记录存在的情况下，我们对主键索引加了记录锁，其他事务就无法删除该记录，也会因为主键冲突无法插入这个主键值的新纪录，在记录不存在的情况下，我们对主键索引加了间隙锁，其他事务就无法在这个间隙范围内插入新纪录，并且由于记录是不存在的，所以右边界的记录是可以被修改或删除的，也就不需要临键锁了，我们只需要保证我们查询的那个主键值的记录得到的结果集是相同的即可，并且由于锁是加在索引上的，我们是没办法对不存在的记录加记录锁的，所以只能加间隙锁

我们可以通过 **`select * from information_schema.innodb_locks\G;`** 来查看事务执行 SQL 过程中加了什么锁，LOCK_TYPE 字段表示锁的范围，如果是 RECORD 就是行级锁，如果是 TABLE 就是表级锁，LOCK_MODE 字段表示锁的类型，**如果是 `X` 说明是临键锁，如果是 `X, REC_NOT_GAP` 说明是记录锁，如果是 `X, GAP` 说明是间隙锁**

**唯一索引范围查询：**

当唯一索引进行范围查询时，MySQL 会**对每个扫描到的索引都加临键锁**

在进行**大于**的范围查询时，MySQL 会在主键索引上加**两个 X 型的临键锁**，例如，`select * from user where id > 15 for update;`，假设表中存在 id = 20 的记录，那么 MySQL 会在主键索引上加两个临键锁，分别是 `(15, 20]` 和 `(20, +∞)`，这样就保证了在这两个范围内的记录不会被其他事务修改或删除，也不会有新的记录被插入进来，从而保证了查询结果集的一致性，在 InnoDB 存储引擎中，会用一个**特殊的在主键索引上的记录 `supremum pseudo-record` 来标识最后一条记录**，在扫描到这个特殊记录时就会加上第二个临键锁

如果是**大于等于**的范围查询，因为存在等值查询的条件，那如果等值查询的记录存在，则会**对该记录单独加上记录锁**，然后**再对后续扫描到的记录加上两个临键锁**，例如，`select * from user where id >= 15 for update;`，假设表中存在 id = 15 和 id = 20 的记录，那么 MySQL 会在主键索引上加**三个锁**，分别是记录锁 `15`，以及两个临键锁 `(15, 20]` 和 `(20, +∞)`，这样就保证了 id = 15 的记录不会被其他事务修改或删除，也不会有新的记录被插入进来，同时也保证了后续范围内的记录的一致性

如果是**小于或者小于等于**的范围查询，如果条件值的记录**不存在**表中，那无论是小于还是小于等于，在扫描到终止范围查询的记录时，都会**对该记录单独加上间隙锁**，例如 `select * from user where id < 6 for update;`，假设表中存在 id = 1 和 id = 5 的记录，那么 MySQL 一共会**加三个 X 型的锁**，分别是 `(-∞, 1]` 的临键锁，`(1, 5]` 的临键锁，以及对第三行 id = 10 的记录加上间隙锁 `(5, 10)`，这样就保证了在这三个范围内的记录不会被其他事务修改或删除，也不会有新的记录被插入进来，从而保证了查询结果集的一致性，小于等于的语句在不存在的情况下也是一样的

如果是**小于并且条件值的记录存在**，扫描到终止范围查询的记录时，会对该记录的索引加上**间隙锁**，例如 `select * from user where id < 10 for update;`，假设表中存在 id = 1、5 和 10 的记录，那么 MySQL 一共会**加三个 X 型的锁**，分别是 `(-∞, 1]` 的临键锁，`(1, 5]` 的临键锁，以及对第三行 id = 10 的记录加上间隙锁 `(5, 10)`，这样就保证了在这三个范围内的记录不会被其他事务修改或删除，也不会有新的记录被插入进来，从而保证了查询结果集的一致性

如果是**小于等于**并且条件值的记录**存在**，扫描到终止范围查询的记录时，这个记录**还是会被加上临键锁**，例如 `select * from user where id <= 10 for update;`，假设表中存在 id = 1、5 和 10 的记录，那么 MySQL 一共会加**三个 X 型的锁**，分别是 `(-∞, 1]` 的临键锁，`(1, 5]` 的临键锁，以及对第三行 id = 10 的记录加上临键锁 `(5, 10]`，这样就保证了在这三个范围内的记录不会被其他事务修改或删除，也不会有新的记录被插入进来，从而保证了查询结果集的一致性

范围索引的核心就是**当找到第一条不符合范围查询条件的记录时**，就会在该记录上针对不同情况加上不同的锁，从而**避免幻读**

**非唯一索引等值查询：**

在使用非唯一索引进行等值查询时，因为存在两个索引，一个主键索引，一个二级索引，所以在加锁时 MySQL 会**同时对这两个索引都加锁**，但对主键索引加锁的时候只有满足查询条件的记录才会对它们的主键索引加锁，在对二级索引进行加锁分析时，要先对该索引进行**排序**，这样才能清楚知道锁范围的左边界

如果查询的记录**不存在**，由于不是唯一索引，查询的过程肯定是一个扫描的过程，MySQL 会**先定位到第一条不符合查询条件的二级索引记录**，对该记录加上**间隙锁**，例如 `select * from user where age = 25 for update;`，假设表中存在 age = 22 和 age = 39 的记录，那么 MySQL 会在二级索引上加上一个 X 型的间隙锁 `(22, 39)`，从而阻止其他事务插入中间范围值的记录

插入语句在插入一条记录之前，会**先定位到该记录在 B+ 树上的位置**，如果**插入的位置下一条记录的索引上有间隙锁时**，才会发生阻塞，二级索引的 B+ 树是按照二级索引的列的值的顺序来存放的，在相同的二级索引列的值的情况下，会按照主键列的值的顺序来存放

那么在上面的例子对于边界值的插入的情况下，如果其他事务插入的了一条 `age = 22, id = 3` 的记录，这时定位到插入的位置的下一条记录是 `age = 22, id = 10`，该记录的二级索引上没有间隙锁，所以这条插入语句可以执行成功，但如何插入的是 `age = 22, id = 12` 的记录时，发现该插入位置的下一条记录是 `age = 39, id = 20`，该记录的二级索引上是有间隙锁的，所以这条插入语句就会被阻塞

如果是 `age = 39, id = 3` 的记录插入时，定位到插入位置的下一条记录是 `age = 39, id = 20`，该记录的二级索引上是有间隙锁的，所以这条插入语句也会被阻塞，但如果插入的是 `age = 39, id = 21` 的记录时，定位到插入位置的下一条记录不存在，也就没有间隙锁了，所以这条插入语句可以执行成功

所以，边界值的插入语句是否可以执行成功，是要**看插入记录的主键值的**，因为我们**需要二级索引值 + 主键值才能确定要插入的位置**，**从而判断该位置的下一条记录的二级索引上是否有间隙锁**，这时通过 **`select * from information_schema.innodb_locks\G;`** 查看锁信息时，会发现 LOCK_MODE 字段显示的是 `X, GAP`，**LOCK_DATA** 字段显示的是 **`39, 20`**，**39** 代表的是 age 值，也就是二级索引列的值，标识锁住的范围的**右边界**，**20** 代表的是**主键列**的值，标识锁住的范围的右边界对应的主键值

如果查询的记录**存在**，例如现在表里有 `age = 21, id = 5`、`age = 22, id = 10`、`age = 39, id = 20` 这三条记录，如果查询语句是 `select * from user where age = 22 for update;`，一共会加**三个锁**，找到之后会先对这个二级索引记录加上范围是 `(21, 22]` 的 X 型临键锁，然后如果扫描到的第二行是 `age = 39` 的记录，该记录是**第一个不符合条件的二级索引记录**，就会对该记录加上 X 型的间隙锁 `(22, 39)`（防止发生幻读），最后还会对查询到的记录对应的**主键索引加上 X 型的记录锁**，从而保证了查询结果集的一致性

如果这时插入 age = 21 的新纪录的 id 值小于 5，那就是可以插入成功的，因为下一条记录的二级索引上没有间隙锁，如果大于 5 就会插入失败，如果插入的是 age = 22 的新纪录，并且 id 小于 10，那就会发生阻塞，如果大于 10，因为有间隙锁，也会被阻塞，如果插入的是 age = 39 的新纪录，并且 id 小于 20，那也会被阻塞，如果大于 20 就可以插入成功，同时，我们也无法更新或删除 id = 10 的记录，因为它的主键索引上有记录锁

**非唯一索引范围查询：**

非唯一索引在进行范围查询时，对二级索引加的锁**都是临键锁**，例如 `select * from user where age >= 22 for update`，查到了 `age = 22, id = 10` 和 `age = 39, id = 20` 这两条记录，假设表里在 age = 22 前面的一条记录是 `age = 21, id = 5`，这里一共就会加**五个锁，三个临键锁，两个记录锁**，就是范围分别是 `(21, 22]`、`(22, 39]` 和 `(39, +∞)` 的 X 型临键锁，以及对这两条记录对应的主键索引加上 X 型的记录锁，**如果只对二级索引加记录锁**的话，由于 age 字段是**非**唯一索引，**没有唯一性**，只加了记录锁就无法防止其他事务插入一条 age = 22 但主键值不同的记录，记录锁只能防止删除或修改，这样就会导致幻读现象

**总结：**

如果是没有加索引的查询，或者查询语句没有走索引，那就会导致**全表扫描**，这样的话每一条记录的索引上都会加上临键锁，就相当于**把全表都锁住了**，如果这时其他事务对该表进行 CRUD 操作时，都会被阻塞，直到锁被释放

* **唯一索引等值查询**
  * 查询的记录**存在**
    * 在索引树上定位到这条记录后，会对该记录的索引加上 X 型的记录锁
  * 查询的记录**不存在**
    * 在索引树上定位到第一条大于该查询记录的记录后，找到它的前一条记录，然后锁定这两条记录之间的间隙范围，加上 X 型的间隙锁
* **非唯一索引等值查询**
  * 查询的记录**存在**
    * 在索引树上定位到这几条（不是唯一）记录后，会对该记录的索引加上 X 型的临键锁
    * 然后继续扫描索引树，直到扫描到第一条不符合查询条件的记录，对该记录加上 X 型的间隙锁
    * 最后对查询到的记录对应的主键索引加上 X 型的记录锁
  * 查询的记录**不存在**
    * 在索引树上定位到第一条不符合条件的二级索引记录，对该记录加上 X 型的间隙锁
    * 不会对主键索引加锁
* **唯一索引范围查询**
  * 在满足一定条件时，会对索引加间隙锁或记录锁，而不是临键锁
* **非唯一索引范围查询**
  * 永远加的都是临键锁

在考虑 MySQL 是怎么加锁时，主要要以**怎么样才能避免幻读的角度**去分析，就会比较好理解这些加锁的规则

#### 
