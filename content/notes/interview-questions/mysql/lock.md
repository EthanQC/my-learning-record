## 锁
#### MySQL 有哪些锁？

根据加锁的范围，可以分为**全局锁、表级锁和行锁**三种

**全局锁：**

使用 **`FLUSH TABLES WITH READ LOCK`** 语句可以**对整个数据库实例加全局读锁**，执行后，整个数据库就处于**只读状态**了，如果要释放全局锁则要执行 **`UNLOCK TABLES`** 语句，**在会话断开时全局锁也会被自动释放**

全局锁主要应用于做**全库的逻辑备份**，这样在备份期间就不会因为数据或表结构的更新而导致备份文件的数据与预期的不一致

如果数据库里有很多数据，备份就会花费很多时间，导致业务停滞，但如果开启了**可重复读隔离级别**的事务，那在备份之前先开启事务，这样由于**整个事务执行期间**用的都是这个 Read View，在 MVCC 的支持下，备份期间业务依然可以对数据进行更新操作，因为即使其他事务更新了表的数据，当前事务依然可以读取到事务开始时的数据快照，这就是事务四大特性中的**隔离性**，这样就不用使用全局锁了

备份数据库的工具是 mysqldump，使用时加上 `--single-transaction` 参数即可开启一个事务来进行备份，但只适用于支持可重复读隔离级别的存储引擎，比如 InnoDB

**表级锁：**

* **表锁**
  * **读锁**
    * 表级别的**共享锁**，允许当前会话读取表中的数据，但**不允许其他会话对表进行写操作**
    * `LOCK TABLES table_name READ;`
  * **写锁**
    * 表级别的**排他锁**，允许当前会话对表进行读写操作，但**不允许其他会话对表进行任何读写操作**
    * `LOCK TABLES table_name WRITE;`
  * 表锁除了会限制别的线程的读写外，**也会限制当前线程接下来的读写操作**
  * 例如，在某个线程中执行了 `lock tables t1 read, t2 write;` 之后，其他线程写 t1、读写 t2 的语句都会被阻塞，并且，当前线程只能对 t1 执行读操作，对 t2 执行读写操作，不能对 t1 执行写操作，直到执行 `unlock tables;` 释放锁
  * 在释放锁之前，当前线程也不能访问其他表
  * 当会话退出后，也会释放所有表锁
  * 在还没有出现更细粒度的锁时，表锁就是最常用的处理并发的方式
* **元数据锁（MDL，Metadata Lock）**
  * 不需要显式使用，当我们对数据库表进行操作时，MySQL 会**自动**为表加上元数据锁
    * 对一张表进行 **CRUD** 时，加的是 **MDL 读锁**
    * 对一张表进行 **DDL** 操作时，加的是 **MDL 写锁**
  * 当有线程在执行 CRUD 时，如果其他线程想对该表进行 DDL 操作，就会被阻塞，如果执行的是 DDL 操作，其他线程想对该表进行 CRUD 操作也会被阻塞
    * 但是多个线程同时执行 CRUD 操作时，是不会互相阻塞的
  * MDL 在事务提交后才会释放，也就是说在事务执行期间，MDL 是一直持有的
    * 如果线程 A 先启用了事务，但是一直不提交，它执行了一条 select 语句，就会先对该表加上 MDL 读锁
    * 然后线程 B 也执行了同样的 select 语句，这时线程 B 不会被阻塞，因为 **MDL 读锁是可以共享**的，也就是**读读并不冲突**
    * 然后线程 C 修改了表字段，但由于 A 的事务还没有提交，也就是 MDL 读锁还没有释放，所以线程 C 申请不到 MDL 写锁，就会被阻塞
    * 此时在 C 阻塞后，后续所有对该表的 select 语句也会被阻塞，因为所有申请 MDL 锁的操作会形成一个队列，队列中**写锁的获取优先级是高于读锁**的
* **意向锁**
  * 在使用 InnoDB 引擎的表里对某些记录加上共享锁之前，要先在表级别加上一个**意向共享锁**
  * 独占锁也是同理，在对某些记录加上独占锁之前，要先在表级别加上一个**意向独占锁**
  * 意向共享锁和意向独占锁是表级锁，**不会和行级的共享锁和独占锁冲突**，**意向锁之间也不会发生冲突**，只会和共享表锁和独占表锁冲突
  * 表锁和行锁是满足读读共享、读写互斥、写写互斥的
  * 如果没有意向锁，那在加独占表锁时，就需要**遍历整张表的所有记录**，查看是否有行锁存在，这样会非常低效，而有了意向锁后，只需要查看表级别的意向锁就可以知道是否有行锁存在，从而提高了加锁的效率
* **AUTO-INC 锁**
  * 一张表里的主键通常都会设置成**自增**的，是通过对主键字段声明 `AUTO_INCREMENT` 来实现的，之后插入数据时就可以不用指定主键的值，数据库会自动给主键赋递增的值，这就是通过 AUTO-INC 锁来实现的
  * AUTO-INC 锁是一种**表级的特殊锁**，它不是在一个事务提交后才释放，而是**在执行完插入语句之后就会释放**，在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 `AUTO_INCREMENT` 声明的字段生成下一个自增值，最后释放锁
  * 也就是说，一个事务在持有 AUTO-INC 锁的过程中，其他事务如果要向该表插入语句，就会被**阻塞**，直到 AUTO-INC 锁被释放，从而保证插入数据时，被 `AUTO_INCREMENT` 声明的字段生成的值是唯一且连续递增的
  * 但这样如果在大量数据插入的场景下，是会影响性能的，因此 InnoDB 提供了一种**轻量级的锁**来实现自增，也是同样在插入数据时为被 `AUTO_INCREMENT` 声明的字段加上轻量级锁，然后赋一个自增的值，然后就释放锁，而**不需要等待整个插入语句执行完毕才释放锁**
  * InnoDB 提供了 **`innodb_autoinc_lock_mode`** 的系统变量
    * `innodb_autoinc_lock_mode=0`：传统锁模式，使用表级的 AUTO-INC 锁，语句执行结束后才释放锁
    * `innodb_autoinc_lock_mode=1`：普通的 insert 语句使用轻量级锁，批量插入语句还是使用表级的 AUTO-INC 锁
    * `innodb_autoinc_lock_mode=2`：所有插入语句都使用轻量级锁
  * 使用 `innodb_autoinc_lock_mode=2` 是性能最高的方式，但当搭配 **binlog 的日志格式是 statement** 一起使用时，在**主从复制**的场景下会发生**数据不一致**的问题
    * 例如，A 往表里插入了四条数据，生成的自增主键分别是 1、2、3、4，然后 B 建了一个相同结构的表，现在 A 和 B 同时往这个新的表中插入数据，B 先插入了两条数据，生成的自增主键是 1、2，然后 A 申请自增 id 得到 id = 3，插入了这条数据，接着 B 又插入了两条数据，生成的自增主键是 4、5，这时 B 的insert 语句生成的 id 是**不连续**的
    * 而主库发生这种情况时，binlog 面对第二张表的更新，只会记录这两个 session 各自的 insert 语句，在 `binlog_format=statement` 的情况下，记录的就是**原始语句**，顺序要么先是 A 的 insert，要么是 B 的 insert
    * 但无论是哪一种，在 binlog 拿去从库执行时，**从库是按照顺序执行语句的**，因此在从库上是不会有像主库那样 A 和 B 同时执行向第二张表插入数据的场景的，所以在从库上执行了 B 的 insert 语句，生成结果中，自增主键分别是 1、2、3、4，而不是主库上的 1、2、4、5，这样就导致了**主从数据不一致**的问题
    * 要解决这个问题，**binlog 的日志格式要改成 row**，这样在 binlog 里记录的就是**主库分配的自增值**，这样既能提升并发性，又不会出现数据一致性的问题

**行级锁：**

InnoDB 存储引擎支持行级锁，MyISAM 存储引擎不支持行级锁，普通的 select 语句是不会对记录加锁的，因为它属于**快照读**，如果是 `select ... for update` 或者 `select ... lock in share mode` 语句，则会对读取到的记录分别加上**行级的独占锁和共享锁**，但这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，也就是说必须配合 `begin`、`start transaction`、`set autocommit = 0` 和 `commit` 等语句一起使用

在**读已提交**隔离级别下，行级锁只有记录锁，而在**可重复读**隔离级别下，行级锁有记录锁、间隙锁、临键锁和插入意向锁四种

**共享锁（S 锁）满足读读共享，独占锁（X 锁）满足读写互斥和写写互斥**，行级锁主要有以下几种：

* **Record Lock（记录锁）**
  * 记录锁只能放在**已经存在**的记录上
  * 记录锁是有 S 锁和 X 锁之分的，**S 锁和 S 锁是兼容的，X 锁和 X 锁不兼容，S 锁和 X 锁也不兼容**
  * `select * from t_test where id = 1 for update;` 这条语句就是对 id = 1 的记录加上了 X 锁
* **Gap Lock（间隙锁）**
  * 间隙锁存在于**可重复读隔离级别和串行化隔离级别**，目的是为了解决可重复读隔离级别下的**幻读**问题
  * 例如，表中有一个范围 id 是 `(3, 5)` 的间隙锁，那其他事务就无法插入 id = 4 的记录了
  * 间隙锁虽然存在 S 型和 X 型之分，但它们之间是没有区别的，**间隙锁之间是兼容的**，也就是说两个事务是可以同时持有包含共同间隙范围的间隙锁
* **Next-Key Lock（临键锁）**
  * 临键锁是**记录锁和间隙锁的组合**，锁定一个范围的同时锁定记录本身
  * 例如，表中有一个范围 id 是 `(3, 5]` 的临键锁，那其他事务无法插入 id = 4 的记录，也无法修改 id = 5 的记录
  * 如果一个事务获取了 X 型的临键锁，那么另外一个事务在获取相同范围的 X 型临键锁时，是会**被阻塞**的
  * 这是因为虽然相同范围的间隙锁是多个事务相互兼容的，但**对于记录锁，X 锁和 X 锁之间是不兼容的**
* **Insert Intention Lock（插入意向锁）**
  * 一个事务在插入一条记录时，需要判断插入的位置**是否已经被其他事务加了间隙锁**（临键锁也包括间隙锁），如果有的话，就会被阻塞，直到拥有间隙锁的那个事务提交为止
  * 在此期间，就会生成一个**插入意向锁**（此时这个锁并不是真正持有的，它只是一个锁请求，由于此时那个间隙锁还存在，所以这里就是**等待状态的锁**），表明有事务想在某个区间插入新纪录，但现在处于等待状态
  * MySQL 在加锁时，是先生成锁结构，然后设置锁的状态，如果锁是等待状态，并不代表事务成功获取到了锁，只有当锁状态是**正常状态时**，才表示事务成功获取到了锁
  * 插入意向锁虽然名字有意向锁，但它并不是意向锁，它**是一种特殊的间隙锁**，属于行级别锁
  * 如果说间隙锁锁住的是一个区间，那插入意向锁锁住的就是**一个点**，但尽管插入意向锁也属于间隙锁，但**两个事务是不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁的**，此时另一个事务的插入意向锁请求会被阻塞，相当于拿到的是**等待状态**的锁
  * 只有在间隙锁释放之后，插入意向锁才能变成**正常状态**的锁，从而成功插入记录，插入意向锁表示的是**要对这个区间的某个位置进行插入操作的意图**，多个插入意向锁之间通常是**兼容**的，只有在这条新纪录被插入产生后，才会有这条记录的记录锁，插入意向锁说是锁住某个点，但它并不是记录锁

#### 什么 SQL 语句会加行级锁？

普通的 select 语句是不会加行级锁的，因为它属于**快照读**，如果是 `select ... for update` 或者 `select ... lock in share mode` 语句，则会对读取到的记录分别加上**行级的独占锁和共享锁**，但这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，也就是说必须配合 `begin`、`start transaction`、`set autocommit = 0` 和 `commit` 等语句一起使用

另外，**update 和 delete** 操作都会加行级锁，并且锁的类型都是**独占锁**

共享锁满足读读共享、读写互斥，独占锁满足写写互斥、读写互斥

#### MySQL 是怎么加行级锁的？

加锁的对象是索引，基本单位是临键锁，临键锁是左开右闭区间，间隙锁是左开右开区间，在能使用记录所或者间隙锁就能避免幻读现象的场景下，临键锁会退化成记录锁或间隙锁


