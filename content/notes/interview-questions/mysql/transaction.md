## 事务
#### 事务有哪些特性？

主要是 **ACID** 四个特性：

**原子性：Atomicity**

一个事务中的所有操作**要么全部完成，要么全部不完成**，不会结束在中间某个环节，而且如果事务在执行过程中**发生错误**，会被**回滚**到事务开始前的状态，就好像这个事务从来没有执行过一样，原子性主要是通过 **undo log**，也就是**回滚日志**，来实现的

**一致性：Consistency**

事务操作前和操作后，数据满足**完整性约束**，数据库保持一致性状态，不能出现一方数据变化了但另一方数据没有变化的情况，一致性主要是通过持久性 + 原子性 + 隔离性来保证的

**隔离性：Isolation**

数据库允许**多个并发事务同时**对其数据进行读写和修改，但每个事务的操作对其他事务是**隔离**的，隔离性会**防止多个事务并发执行时由于交叉执行而导致数据不一致的问题**，每个事务都有一个完整的数据空间，隔离性是通过 **MVCC**，也就是**多版本并发控制**，或锁机制来保证的

**持久性：Durability**

一旦事务提交，对数据的修改就是**永久性**的，即使系统发生故障也不会丢失，持久性主要是通过 **redo log**，也就是**重做日志**，来实现的

#### 并发事务会带来哪些问题？

主要是**脏读、不可重复读和幻读**三种问题，严重程度是脏读 > 不可重复读 > 幻读

**脏读：**

如果**一个事务读到了另一个未提交事务修改过的数据**，就意味着发生了脏读现象

例如一个事务 A 先开始读取了某个数据，然后它对这个数据进行了更新，但它**还没有提交事务**，这时刚好事务 B 也从数据库中读取了这个数据，事务 B 读到的就是事务 A **修改后的数据**，如果事务 A 最终**回滚**了，那么事务 B 读到的数据就是无效的，这种现象就叫做脏读

**不可重复读：**

在**一个事务内多次读取同一个数据**，如果出现了**前后两次读到的数据不一样**的情况，就意味着发生了不可重复读现象

例如一个事务 A 先从数据库中读取了某个数据，然后它继续执行了其他代码逻辑，还没有提交事务，在这个过程中事务 B **对这个数据进行了更新并提交了事务**，接着事务 A 再次读取这个数据时，就会发现前后两次读取到的数据是**不一致**的

**幻读：**

在一个事务内**多次查询某个范围的数据**，如果前后两次查询结果的**记录数不一样**，就意味着发生了幻读现象

例如一个事务 A 先从数据库中读取到了 5 条记录，另一个事务 B 按照相同的搜索条件也查询出了 5 条记录，接下来事务 A **插入了一条记录并提交了事务**，事务 B 再次按照相同的搜索条件查询时，就会发现结果中多出了一条记录，变成了 6 条记录

#### 事务的隔离级别有哪些？

按隔离级别**从低到高**有**读未提交**（Read Uncommitted）、**读已提交**（Read Committed）、**可重复读**（Repeatable Read）和**串行化**（Serializable）四种隔离级别

**读未提交**（Read Uncommitted）：**允许一个事务读取另一个未提交事务修改过的数据**，因此会发生**脏读、不可重复读和幻读现象**

**读已提交**（Read Committed）：允许一个事务只能读取另一个**已提交**事务修改过的数据，因此不会发生脏读现象，但仍然可能发生**不可重复读和幻读**现象

**可重复读**（Repeatable Read）：确保在一个事务内多次读取同一个数据时，读到的数据跟事务启动时看到的数据是一致的，因此不会发生脏读和不可重复读现象，但仍然可能发生**幻读**现象，**MySQL 的默认隔离级别就是可重复读**

**串行化**（Serializable）：会对记录加上**读写锁**，通过强制事务**串行执行**来避免并发问题，在多个事务对一条记录进行读写操作时，如果发生了读写冲突，后访问的事务必须等待前一个事务执行完成之后才能继续执行，因此不会发生脏读、不可重复读和幻读现象，但**会大大降低系统的并发性能**

MySQL 的可重复读很大程度上避免了幻读现象，所以 MySQL 并不会使用串行化隔离级别来避免幻读问题，因为它会严重影响数据库的并发性能

在 MySQL 中，读已提交和可重复读的隔离级别的事务是通过 **Read View** 来实现的，它们的区别在于创建 Read View 的时机不同，**Read View 相当于是一个数据快照**，读已提交是在**每个**语句执行前都会重新生成一个 Read View，而可重复读是在事务开始时生成一个 Read View，整个事务期间都使用这个 Read View

MySQL 有两种开启事务的命令，分别是 `begin/start transaction` 和 `start transaction with consistent snapshot`，前者在执行之后并不代表事务启动，只有执行之后的第一个读写操作才会真正启动事务，而后者在执行之后就会立即启动事务并创建一个一致性快照

#### Read View 在 MVCC 里是如何工作的？

**Read View** 有下面四个重要的字段：

![read-view](read-view.png)

在**聚簇索引**中，还会有 **`trx_id` 和 `roll_pointer` 两个隐藏字段**，分别表示该行数据是由哪个事务创建的，以及用于回滚的指针，当一个事务对某条聚簇索引记录进行改动时，就会把**该事务的事务 id** 记录在 `trx_id` 字段中，并把**旧版本的记录**写到 undo log 中，然后会把该记录的回滚指针记录在 `roll_pointer` 字段中

在创建 Read View 后，**MVCC（多版本并发控制）**会通过**版本链**的方式来**控制并发事务访问同一个记录时的行为**，记录中的 `trx_id` 主要有三种情况：

![trx-id-version](trx-id-version.png)

如果记录的 `trx_id` 值**小于** Read View 中的 `min_trx_id`，说明这个版本的记录是在创建 Read View **之前**就**已经提交**的事务所创建的，因此这个版本的记录对当前事务是**可见**的

如果记录的 `trx_id` 值**大于** Read View 中的 `max_trx_id`，说明这个版本的记录是在创建 Read View **之后**才开始的事务所创建的，因此这个版本的记录对当前事务是**不可见**的

如果记录的 `trx_id` 值**介于** Read View 中的 `min_trx_id` 和 `max_trx_id` 之间，则需要**判断**该 `trx_id` 是否在 `m_ids` 列表中，如果**在**的话，就表示生成该版本记录的活跃事务**仍然活跃**着（还没提交事务），因此该版本记录对当前事务是**不可见**的；如果**不在** `m_ids` 列表中，说明生成该版本记录的事务**已经提交**了，因此该版本记录对当前事务是**可见**的

#### 可重复读是如何工作的？


