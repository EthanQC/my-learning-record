## 日志
#### undo log、redo log 和 binlog 分别是什么？

**undo log（回滚日志）**是 InnoDB 存储引擎层生成的日志，实现了事务中的**原子性**，主要用于**事务回滚和 MVCC**

**redo log（重做日志）**也是 InnoDB 存储引擎层生成的日志，实现了事务中的**持久性**，主要用于**掉电**等故障恢复

**binlog（归档日志）**是 server 层生成的日志，主要用于**数据备份和主从复制**

#### 为什么需要 undo log？

我们在执行增删改的语句时，mysql 会**隐式自动开启事务**来执行，执行完毕就自动提交，如果这个事务在执行过程中，MySQL 发生了**崩溃**，就需要使用 **undo log** 来**回滚**到事务之前的数据，事务的**原子性**就是这样实现的

**undo log 是一种用于撤销回退的日志**，在事务没提交之前，MySQL 会记录更新前的数据到 undo log 中，比如在插入一条记录时，会把这条记录的主键值记下来，回滚时只要把这个主键值对应的记录删掉就好了，删除和更新也是同理，都是**做原先的相反操作**，但 delete 其实不会立即删除，而是将要被删除的对象打上 delete flag，标记为删除，最终由 purge 线程完成删除，update 就要看更新的列是否是主键列，不是的话就在 undo log 中直接反响记录是如何 update 的，是的话就先删除该行，再插入一条目标行，**不同的操作需要记录的内容是不同的，对应所产生的 undo log 的格式也是不同的**

undo log 的另外一个作用是**配合 ReadView 实现 MVCC（多版本并发控制）**，一条记录的每一次更新操作产生的 undo log 的格式都有一个 **roll_pointer 指针和一个 trx_id 事务 id**，roll_pointer 可以**将这些不同版本的 undo log 串成一个链表**，这个链表就被称为**版本链**，trx_id 可以**标识该记录是被哪个事务修改的**

对于**读已提交**隔离级别来说，它是**每个 select 都会生成一个新的 ReadView**，也就是说事务期间多次读取同一条数据，前后两次读到的数据可能会出现不一致，对于**可重复读**隔离级别来说，它只会**在事务开始时生成一个 ReadView**，然后整个事务期间都用这个 ReadView，事务期间多次读取同一条数据，前后两次读到的数据是一致的

这两个隔离级别都是通过 **MVCC** 实现的，也就是**快照读**，它们会根据事务的 ReadView 里的字段和记录中的 trx_id 和 roll_pointer 这两个隐藏字段来**判断该记录的版本是否对当前事务可见**，如果不可见，就通过 roll_pointer 指针顺着 undo log 版本链找到对应的 undo log，然后根据 undo log 里的内容来还原出该记录对当前事务可见的版本

所以，undo log 就是**实现事务回滚**，保障事务的原子性，和**配合 ReadView 实现 MVCC**，这两个主要的功能，undo log 和数据页的刷盘策略是一样的，都要**通过 redo log 来保证持久化**，buffer pool 中有 undo 页，对 undo 页的修改也会记录到 redo log，redo log 会每秒刷盘，提交事务时也会刷盘，从而保证持久化

#### 为什么需要 redo log？

Buffer Pool 是基于内存的，为了防止断电导致数据丢失的问题，当有一条记录需要更新时，InnoDB 会**先更新内存**，然后将本次对这个页的修改**以 redo log 的形式记录下来**，后面再由后台线程将脏页刷新到磁盘里，这就是 **WAL**（Write Ahead Logging）技术，指的是 **MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，再在合适的时间写到磁盘上**

![wal](wal.png)

redo log 会记录某个数据页做了什么修改，每当执行一个事务就会产生这样的一条或多条物理日志，在**事务提交**时，只要**先将 redo log 持久化到磁盘即可**，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘，这样即使系统崩溃，虽然脏页数据没有持久化，但重启之后可以根据 redo log 的内容将所有数据恢复到最新状态，这个能力称为 crash-safe，崩溃恢复

undo log 被更新了之后也会产生对应的 redo log，redo log 记录的是此次事务修改**后**的数据状态，记录的是更新**之后**的值，主要用于**事务崩溃恢复**，保证事务的**持久性**，而 undo log 记录的是此次事务修改**前**的数据状态，记录的是更新**之前**的值，主要用于**事务回滚**，保证事务的**原子性**，如果是在事务提交之前崩溃（事务执行错误），就会通过 undo log 来回滚事务

![recover](recover.png)

而写入 redo log 的方式是**追加操作**，在磁盘中就是**顺序写**，但直接把数据写入磁盘则需要**先找到写入位置，再进行写入**，是**随机写**，顺序写的效率要远高于随机写，所以 redo log 写入磁盘的开销更小，这也是我们需要它的另一个原因

总结：redo log 实现了事务的**持久性**，让 MySQL 具备崩溃恢复能力，同时**将写操作从随机写变成了顺序写**，大大提升了写入性能

redo log 本身也不是直接写入磁盘的，它也有自己的缓存，叫 **redo log buffer**，redo log 先写入 redo log buffer，然后由后台线程定期将 redo log buffer 刷新到磁盘上的 redo log 文件中，缓存大小默认是 16 MB，可以通过参数 `innodb_log_buffer_size` 来配置，增大它的大小可以让 MySQL 处理大事务时不需要写入磁盘

#### redo log 什么时候刷盘？

主要是下面几种情况：

* **MySQL 正常关闭时**
* redo log buffer 中记录的写入量**大于** redo log buffer 内存空间的**一半**时
* InnoDB 的**后台线程每隔一秒**会将 redo log buffer 刷新到磁盘上一次
* 每次**事务提交**时，都会将缓存里的 redo log 刷新到磁盘上

**`innodb_flush_log_at_trx_commit`** 参数**控制每次事务提交时 redo log 的刷盘策略**，默认值是 **1**，表示**每次**事务提交时都会将缓存里的 redo log **直接持久化到磁盘上**，这样可以保证 MySQL 异常重启后数据不会丢失，为 **0** 时表示**每次**事务提交时都把 redo log **留在缓存中**，该模式下事务提交不会主动触发写入磁盘的操作，为 **2** 时表示**每次**事务提交时都只是把缓存中的 redo log **写到 redo log 文件**，并没有写入磁盘，也就是**写入了操作系统的文件缓存**，就是**页缓存**

![flush-strategies](flush-strategies.png)

也就是说，InnoDB 的后台线程每隔一秒，在参数为 0 的情况下，会调用 `write()` 函数把 redo log 缓存里的 redo log 写到操作系统的页缓存，然后调用 `fsync()` 持久化到磁盘，也就是说在这种策略下，**MySQL 进程到崩溃会导致上一秒所有事务数据的丢失**

如果参数为 2，后台线程也是每隔一秒，但它会直接调用 `fsync()` 来做持久化，也就是 **MySQL 进程崩溃不会导致数据丢失，只有在操作系统崩溃或者系统断电的情况下上一秒的所有事务数据才可能丢失**

所以，**参数为 1 时数据最安全，但性能最差，参数为 0 时性能最好，但数据最不安全**，参数为 2 时性能和数据安全性介于两者之间，在一些对数据安全性要求比较高的场景中，应该把参数值设为 1

#### 如果 redo log 文件写满了，该怎么办？

InnoDB 存储引擎在默认情况下有一个**重做日志文件组**，里面包含两个分别叫做 `ib_logfile0` 和 `ib_logfile1` 的重做日志文件，这两个文件是**循环使用**的，当一个文件写满之后，就切换到另一个文件继续写入，另一个文件也写满了之后，就会切换回第一个文件，这两个文件的大小是固定且一致的，随着系统运行，Buffer Pool 里的脏页被刷新到磁盘之后，这些脏页对应的 redo log 就不再需要了，就可以擦除这些旧记录

![redo-log-file](redo-log-file.png)

循环写的方式相当于这样一个**环形**，**write pos** 和 **checkpoint** 分别表示**当前写到的位置**和**当前要擦除的位置**，它们都是顺时针方向移动，红色部分用来记录新的更新操作，蓝色部分表示待落盘的脏页数据

如果 write pos 追上了 checkpoint，就说明 redo log 文件**满了**，这时 MySQL 不能再执行新的更新操作，也就是会被阻**塞**，这也是为什么对于并发量大的系统，适当设置 redo log 的文件大小是重要的，满了之后就会**先停下来将 Buffer Pool 里的脏页刷新到磁盘中**，然后标记 redo log 里哪些对应的记录可以被擦除，再擦除，擦除之后 checkpoint 继续往后移动，MySQL 才会恢复正常运行

#### 为什么需要 binlog？

