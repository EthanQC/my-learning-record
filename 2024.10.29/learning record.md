## 几道二分查找算法题（编号为leetcode上的题目编号）
### 35.搜索插入位置
#### [题目](https://leetcode.cn/problems/search-insert-position/description/)：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。
我的解答可在[此处](https://github.com/EthanQC/My-LearningHub-StudyJourney-with-cpp/blob/947ef1438eacb96ca06f4e8d0c0159ea3920eba0/2024.10.29/35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.md)找到

这道题其实是上一道题的变形，跟上一题基本完全一样，不一样的地方在于需要找到是什么代表了**按顺序插入的位置**，我们可以进行以下分析：
- 在二分查找过程中，left和right代表的是查找范围的左边界和右边界，并随着查找的推进不断更新
- 当left大于right时，二分查找自然退出，此时我们留意**left停留的位置，刚好停在第一个大于target的元素的位置**，否则二分查找无法退出
- 也就是说，在一般情况下，left停留的位置刚好就是target应该插入的位置（如果target不在数组中的话）
- 在边界情况下，比如target比数组中所有元素都大或者都小，left也会分别停留在数组的末尾或者初始位置，也仍然是target应该插入的位置
- 如果使用right则会导致插入位置偏左
- 如果使用right + 1则会导致在边界情况下，插入位置错误，比如target比所有元素都小时

这道题其实不难，重点还是在如何对于按顺序插入target的位置的寻找；马后炮地说，其实在二分查找中一共就三个位置变量，left、right、middle，即使一开始没思路，也可以聚焦与这三个位置变量的变化情况，本质上考察的还是对于二分查找是否足够熟悉或深入；该算法的时间复杂度：O(log n)，空间复杂度：O(1)

需要注意的是，left和right变量要在while循环**外面**创建并初始化为0，而middle变量则需要在while循环**里面**创建并初始化，这是因为left和right变量在while中会不断被更新，所以我们不能把它们放到循环内，否则会导致重复的初始化，进而导致了无限循环，而middle变量则是循环每次开始时都会被更新的，自然也不能被放在循环外面，否则二分查找是无法正常进行的，这两个错误我在写的时候都犯了，我一开始把三个变量全放在了循环里面，然后修改了一下，结果又把三个变量全放在了循环外面🤣，写代码的时候脑子一定要清晰才行！！

### 34.在排序数组中查找元素的第一个和最后一个位置
#### [题目](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
我的解答可在[此处](https://github.com/EthanQC/My-LearningHub-StudyJourney-with-cpp/blob/4b3c258f7c7c41ca4b235e6995e8e0d9570b5571/2024.10.29/34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.md)找到

**非递减顺序**：意味着数组中元素值不会递减，简单来说就是*递增*或*持平*，所以可以将它理解为*递增顺序*，只是可能包含相同的元素

这道题可以说是二分查找的升级版，因为现在数组中出现了重复的元素，这就导致二分查找的难度大大增加，作为初学者（相信上面那题的注意事项已经让你相信了我是一个彻底的初学者），我们可以考虑**使用两个二分查找来分别找到重复元素的左边界和右边界**（题目已经假设所有相同元素都是**相邻的**），下面是分析过程：
- 写两个函数，分别代表两次二分查找，第一次二分查找找到左边界，第二次二分查找找到右边界
- 再用另一个主函数来调用这两个函数，并创建两个变量来记录两个二分查找函数的返回值，最终返回一个区间
- 查找左边界的函数（返回值应当是int类型）
  + 创建left、right、leftBoundart变量，将leftBoundary初始化为-1，方便记录如果数组中不存在目标值的情况
  + 创建一个while循环，创建middle变量，进入二分查找
  + 如果middle < target，说明目标数在更大的右半边，我们需要更新left变量
  + 如果middle >= target，说明目标数在更小的左半边，我们需要更新right变量
    * 如果middle = target，则说明找到了重复的目标值之一，于是我们将middle赋给leftBoundary
    * 但二分查找仍需要继续，继续寻找此时middle的左边是否仍有相同的元素，**因为我们并不确定这个位置就是最左位置**，而这将通过while循环实现，直到left大于right，循环才会退出，此时我们才找到了左边界
    * 所以，无论是小于还是等于，我们都要更新right变量，以便检查左边部分，最终left会停留在最左边的target位置上
- 查找右边界的函数同理，只要更改一下if判断的条件即可，不再重复叙述
- 主函数
  + 创建左右边界变量，接收两个函数的值
  + 如果两个变量的值有一个为-1， 说明目标数不在数组中，直接返回两个-1
  + 最终返回两个边界值

这道题是**中等难度**类型的题目，但逻辑其实不算特别复杂，只是我们这种初学者没有见过这样的题目，容易没有思路，或者自己把自己绕进去，据说这题的代码简洁度还有很大的提升空间，但我想这并不是现阶段的我们需要留意的；该题的时间复杂度仍为O(log n)，空间复杂度仍为O(1)

其实一开始我是想写两个while循环嵌套在一起，但这样实在是太混乱了，也很容易造成逻辑错误或者赋值问题，错误代码也可以在我的解答里面找到，但非常不建议模仿，哈哈哈哈哈哈哈

感觉其实写代码就是这样，自己一开始写的可能跟实际正确的代码相差千里，但这并没有什么，真的没关系，因为我们本身就是学习者，我们现在要做的就应该是，读完题目之后**大胆地按照自己的想法先写一遍**，如果没有思路或者发现写出来的东西无法正确运行，当然可以先思考一下，**但千万不要死磕太久**，重要的是去看别人正确的代码是怎么写的（比如看题解或者问chatgpt），然后学习正确代码的逻辑和规范，这样我们才能提升效率并且走得更远

### 69.x的平方根
#### [题目](https://leetcode.cn/problems/sqrtx/description/)：给你一个非负整数 x ，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去。注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
我的解答可在[此处](https://github.com/EthanQC/My-LearningHub-StudyJourney-with-cpp/blob/a6f34f284a588428e0e7115e48570f9a761f49fd/2024.10.29/69.x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.md)找到

这题一开始很容易没有思路，而且也很难联想到要用二分查找，但其实二分查找可以帮助我们快速找到满足条件的整数，思路如下：
- 将问题**转化为寻找一个mid**，使得`mid * mid = x`，从而求解
- 需要注意if的条件，当`mid <= x / mid`时，**不但需要修改left边界，也需要更新结果值**，这样才能让二分查找继续下去

此题较为简单，但要注意防溢出时，由于使用了除法，可能会带来一些麻烦，比如**除0问题和整除问题**（这个会在下一题中看到），所以需要注意初始化的情况，或者**直接使用long和long long**

### 367.有效的完全平方数
#### [题目](https://leetcode.cn/problems/valid-perfect-square/description/)：给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。完全平方数是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。不能使用任何内置的库函数，如  sqrt 。
我的解答可在[此处](https://github.com/EthanQC/My-LearningHub-StudyJourney-with-cpp/blob/efaee4202de53d7511bd5bfee1d053a17c62db73/2024.10.29/367.%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md)找到

这题其实就是上一题的升级版，多了一个需求，但具体实现是差不多的，只是有一些细节要注意，我一开始写的时候遇到了下面几个问题（错误代码也在解答里面）：
- num小于2时，可以直接返回真，没必要再计算一次平方根了
- 在我的while循环中，虽然我的操作没问题，也更新了square值，但循环结束后square可能可能只是一个接近平方根的数，而**不一定就是num的真正平方根**（其实我这里还是受到了前面两题的影响，导致对二分查找的使用有些僵化，但实际二分查找的应用是可以根据需求灵活变化的）
- 没有考虑到**除法引入的精度误差**

整体来说这题也不算很难，只是容易陷入思维陷阱，还是要学会变通才行，灵活使用if判断

## 一些知识



## 碎碎念
