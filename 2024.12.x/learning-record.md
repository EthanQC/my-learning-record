## 一些知识
### lambda表达式


### 对象移动
在很多情况下都会发生对象拷贝，而如果对象拷贝后就立即被销毁了，那这时移动而非拷贝对象会大幅度提升性能，为了支持移动操作，不可避免的就是右值引用

>左值和右值都是表达式的属性，通常出现在表达式的左侧和右侧
>
>左值：表示一个对象的身份，如变量、函数名
>
>右值：表示对象的值，如代数运算表达式、匿名的lambda表达式（临时对象）

右值引用就是必须绑定到右值的引用，通过`&&`来获得，它只能绑定到一个将要销毁的对象；右值引用允许我们可以将右值作为参数传递给函数，比如一个**临时的**lambda表达式

而`std::move`函数则允许我们告诉编译器，我们现在有一个左值，但我们希望像一个右值一样处理它，也就是说通过这个函数，我们可以把一个左值作为右值使用，并传递给其他函数，从而实现了对象移动

那么，既然是这样使用的话，我们为什么不直接使用左值引用（即普通的`&`引用）呢？

这就回到了最开始的话题，我们希望移动对象而非拷贝对象，如果使用左值引用，我们只能将左值作为常量引用传递，而无法修改或移动它；另外，左值引用也无法传递一个临时对象

### 原子性 `<atomic>`


### epoll


### 异常 `<stdexcept><system_error>`


### constexpr


### muduo


### `<functional>`
`function`是cpp11中引入的一个通用多态的函数封装器，是`functional`头文件中提供的模板，用来统一封装具有同种返回值、参数类型但不同的可调用对象（函数、lambda等）

语法：`std::function<返回类型(参数类型列表)> 可调用对象名`

### typedef
`typedef`是cpp11新特性，用于为现有数据类型创建别名，但在现代cpp中，大多使用using

    typedef std::function<void()> Function;

    using Function = std::function<void()>; //等同于使用typedef

### `<mutex>`


### `<thread>`


### `<chrono>`


## 碎碎念