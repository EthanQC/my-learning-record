## 一些知识
### lambda表达式


### 对象移动
在很多情况下都会发生对象拷贝，而如果对象拷贝后就立即被销毁了，那这时移动而非拷贝对象会大幅度提升性能，为了支持移动操作，不可避免的就是右值引用

>左值和右值都是表达式的属性，通常出现在表达式的左侧和右侧
>
>左值：表示一个对象的身份，如变量、函数名
>
>右值：表示对象的值，如代数运算表达式、匿名的lambda表达式（临时对象）

右值引用就是必须绑定到右值的引用，通过`&&`来获得，它只能绑定到一个将要销毁的对象；右值引用允许我们可以将右值作为参数传递给函数，比如一个**临时的**lambda表达式

而`std::move`函数则允许我们告诉编译器，我们现在有一个左值，但我们希望像一个右值一样处理它，也就是说通过这个函数，我们可以把一个左值作为右值使用，并传递给其他函数，从而实现了对象移动

那么，既然是这样使用的话，我们为什么不直接使用左值引用（即普通的`&`引用）呢？

这就回到了最开始的话题，我们希望移动对象而非拷贝对象，如果使用左值引用，我们只能将左值作为常量引用传递，而无法修改或移动它；另外，左值引用也无法传递一个临时对象

### 原子性 `<atomic>`


### RAII和异常安全 `<stdexcept><system_error>`
RAII (Resource Acquisition Is Initialization)：
是C++中一种资源管理思想。资源（例如内存、文件描述符、锁）在对象构造函数中获取，并在该对象析构函数中释放。当对象生命周期结束时，资源必然被释放。这种管理方式让资源释放变得自动和确定，不依赖于外部的手动释放调用，从而减少内存泄漏、句柄泄漏。

异常安全（Exception Safety）：
指的是在发生异常时，程序或组件仍能维持良好状态，不会泄漏资源或处于不一致状态。RAII的广泛使用也有助于实现异常安全。当异常抛出时，栈展开会调用对象的析构函数，从而确保资源释放，保证程序不崩溃或资源不遗失。

### constexpr


### explicit
为什么函数声明时使用了explicit，但在函数实现时就不需要再加explicit了？

在C++中，explicit关键字用于构造函数或者单参函数声明处，以防止编译器进行隐式类型转换。当我们在类的头文件中声明构造函数时，如果希望该构造函数不能被隐式调用（例如不能用ClassName c = value;这种隐式转换方式来构造对象），就需要在声明时加上explicit。

一旦在类的声明（通常在头文件）中给构造函数添加了explicit，编译器对该函数的特性已经确定。在函数的实现（通常在cpp文件中）时，explicit的属性已由声明部分确定，不需要再次标注。即explicit只需要在函数的声明处出现一次，之后在实现定义处不需要重复。

在C++中，explicit关键字主要用于构造函数（以及转换运算符）的声明部分，以防止隐式类型转换。当你在类的头文件中声明一个构造函数时，如果在它前面加上explicit，表示该构造函数只能用于显式构造（即必须明确调用，而不是通过隐式转换）。
函数实现部分（通常在.cpp文件中）不需要重复写explicit的原因是，explicit是一个在函数**声明（即接口定义部分）**中才有意义的修饰符，它会影响调用语法和编译器的类型转换规则。在实现阶段（定义时），编译器已经知道该构造函数是explicit的，不需要再次标注。

简单来说：

explicit出现在类的头文件中（声明处），告诉编译器该构造函数不能被用于隐式转换。
函数实现部分只是对声明的实现，不需要也无法再次添加explicit，因为这不会改变调用方式或语言语义。

### muduo
muduo是一个网络库

one loop per thread的含义：
one loop per thread是muduo的一个设计理念，即每个EventLoop只在它所属的单独线程中运行。这意味着同一个EventLoop的所有操作都在同一个线程中完成，从而简化了并发问题，不需要锁来保护EventLoop本身的数据结构。
主线程（main reactor）只处理新连接事件，然后分发给子线程（sub reactor），每个sub reactor对应一个EventLoop运行在自己的线程中，专门处理其管理下的连接的IO事件。

Muduo使用反应堆（Reactor）模型，核心是EventLoop，内部使用Epoll或Poller作为IO复用工具。Channel表示一个文件描述符的事件和回调，TimerQueue负责定时任务。Acceptor监听新连接事件并通过回调建立TcpConnection。TcpConnection负责读写数据，Buffer管理数据缓冲区。整个模型是事件驱动、回调机制。当有事件产生时，EventLoop通知对应Channel执行回调，回调中处理逻辑（比如读数据、写数据、关闭连接等）。

一个EventLoop对应一个线程：
EventLoop内部调用epoll_wait()阻塞当前线程，等待事件发生。这是该EventLoop的主要循环逻辑。

异步注册新fd、异步任务：
如果在其他线程中想要让这个EventLoop注册一个新的fd（即对epoll进行epoll_add等操作），直接跨线程修改数据结构会有同步问题。为了解决这个问题，Muduo的设计是这样的：

你在另一个线程中想让EventLoop执行某个操作（例如添加一个新的fd监听），你不会直接操作EventLoop内部数据，而是通过一个线程安全的队列/回调列表把这个操作（一个函数）push进去。
推完之后，为了让处于epoll_wait()阻塞中的EventLoop线程醒过来执行这个新操作，你向EventLoop持有的eventfd写入一个字节，eventfd的可读事件会被epoll_wait()检测到。
触发唤醒：
epoll_wait()因为eventfd变得可读而返回（不再阻塞），EventLoop线程从就绪事件列表中发现eventfd可读，执行handleRead()将eventfd中的数据读出，发现有新任务在pending_functions_队列中，就执行它（比如epollerAdd()给新fd注册事件）。执行完后，如果暂时没有其他事情可做，EventLoop线程会再次调用epoll_wait()进入阻塞等待下一个事件。
这整个过程就是一种异步唤醒机制：通过往eventfd写入数据来异步地唤醒原本阻塞在epoll_wait()中的线程。处理完事件后，如果没有其他任务，EventLoop又进入epoll_wait()阻塞，这个循环不断重复。

这是不是边缘触发和异步唤醒的体现？
异步唤醒是指通过eventfd写入数据来唤醒EventLoop，这是一个独立的机制，不一定非要ET模式才可以实现。ET（边缘触发）只是epoll的工作模式，与异步唤醒是两个概念，但二者经常配合使用：

异步唤醒保证了可以跨线程通知EventLoop，让它脱离阻塞去处理新任务。
ET模式则是优化性能的一种措施，减少重复通知事件，要求你在事件发生时一次性彻底处理完可用数据。
所以你的描述是基本对的：

是的，往eventfd写入数据后，epoll_wait()阻塞的EventLoop被唤醒，处理事件之后又回到阻塞状态，再次等待事件发生。这是一种异步事件处理和唤醒机制。

Proactor与Reactor模型的区别：
Reactor模式下，框架只是监听事件（可读可写等），当事件准备就绪后通知用户代码执行实际的I/O操作（用户负责read/write）。
Proactor模式下，I/O操作由操作系统异步完成，当操作系统完成I/O后通知用户代码处理结果（用户只处理完成事件，不需要自己主动调用read/write）。

Reactor：
优点：模型简单清晰，用户对I/O时机有较高控制度；易于在多平台实现（epoll、kqueue、select都能用）。
缺点：需要用户主动进行I/O操作，当并发连接很多且I/O操作复杂时，逻辑稍显繁琐。
Proactor：
优点：异步I/O由操作系统或底层库完成，用户代码更加专注业务逻辑；在正确支持的系统上性能极高。
缺点：依赖底层操作系统对真正的异步I/O支持（如Windows的IOCP），在Linux上实现真正的Proactor较为困难（之前Linux的AIO支持较差，现代Linux有io_uring，但仍是新技术）。

文件描述符（FD）：
在类Unix系统中，文件描述符是一个整数，用于标识已打开的文件、socket、管道或设备。内核使用文件描述符来管理和访问底层资源。可以将其理解为操作系统层面的"文件句柄"。

线程监控的管道（pipe）：
管道是Unix提供的一种单向数据通道，用于进程（或线程）间通信的简单方式。一个管道有两个端：一个用于写数据，一个用于读数据。使用管道可以让工作线程或监控线程互相通信，比如通过往管道写入数据，让另一个线程从管道读到事件触发处理逻辑。

socket：
socket是网络编程中用于建立连接、收发数据的"文件描述符"类型的接口。尽管socket常用于网络（TCP/UDP）编程，但在Unix系统中，socket本身也是一种文件描述符。甚至有Unix域套接字（UNIX domain socket）用于本地进程通信。所以socket在概念上是抽象的I/O端点，不仅限于网络远程通信，也可用于本地通信。

错误码EAGAIN是什么？read()函数是什么？

EAGAIN错误码：
当对一个非阻塞文件描述符执行读或写操作时，如果当前没有数据可读（或无法立即写入），内核不会阻塞调用线程，而是立即返回错误码EAGAIN或EWOULDBLOCK，表示"资源暂时不可用，请稍后再试"。
这在非阻塞I/O编程中很常见，程序需要根据此返回码来判断是否要再次尝试读取或写入数据。

read()函数：
read()是Unix系统调用，用于从文件描述符中读取数据到用户提供的缓冲区中。对于socket来说，read()会尝试从socket的接收缓冲中读数据。如果数据不可用且socket是非阻塞模式，则返回-1并设置errno为EAGAIN。

#### epoll
epoll是什么，epoll和poll的区别是什么？

epoll是Linux内核提供的一种多路复用I/O事件通知的机制。它与select、poll类似，但拥有更高的伸缩性和性能。
区别：
poll每次调用时需要传入一个文件描述符数组，内核需要遍历整个数组来检查事件。这在连接数很大时会有较高的开销。
epoll使用内核中维护的数据结构（红黑树和事件队列），在注册事件时就将感兴趣的文件描述符加入到epoll内核结构中，之后只需调用epoll_wait()等待事件发生，不需要重复传入所有FD列表。这样在大量连接（数以万计）时仍能高效运行，减少了无谓的事件检查开销。

为什么epoll_wait阻塞？
epoll_wait()是IO复用的核心，当没有事件发生时，线程在这里阻塞可以节省CPU资源。当有事件发生（文件描述符可读可写或有定时器事件等），epoll_wait返回，处理相应的事件回调。这种事件驱动模型避免了忙轮询，提高效率。

为什么使用异步唤醒？
当EventLoop在epoll_wait()中阻塞等待事件时，如果需要在其他线程中给这个EventLoop增加一个新的任务（如注册新的fd），就必须唤醒epoll_wait()使其立刻执行。唤醒的方式就是往eventfd写入数据，引发EPOLLIN事件，让eventLoop苏醒过来

为什么要阻塞？
阻塞等待事件可以减少CPU空转，只有在有实际事件需要处理时才唤醒EventLoop。提高服务器资源利用率。

忙轮询（Busy Polling）是什么？
忙轮询是指线程不断地积极检查某个条件是否满足，而不进行阻塞等待的方式。比如，在没有使用epoll的原始阻塞I/O模型下，如果想不停地读数据但又不想阻塞，你可能不断调用read()看看有没有数据，没有就继续调用，这就是一种忙轮询的行为。忙轮询会消耗大量CPU，因为线程不会休眠而是不断空转检查。
IO复用的意义在于避免忙轮询。通过epoll_wait阻塞等待事件发生，一旦事件出现，再处理，不用一直在那儿空转浪费CPU。

#### 边缘触发（ET）
为什么使用ET(边缘触发)？
ET模式在高并发场景下有更高的效率，因为事件只在状态变化时触发，不需要重复通知。但使用ET模式需要保证非阻塞IO，并且在读取或写入数据时一次性尽可能读完或写完缓冲区数据。

#### I/O复用与非阻塞I/O
IO复用是指在一个（或少数几个）线程中同时监控多个文件描述符（如socket、管道、timerfd等）的I/O事件，一旦某个文件描述符变得可读或可写，就会通过内核提供的机制（如select、poll、epoll）通知我们。这意味着我们不需要为每个连接创建一个线程在阻塞式读写上等待，而是通过一个统一的复用接口（如epoll_wait）来管理众多的I/O事件。

在传统的阻塞I/O模型下，为了等待某个socket有数据可读，线程可能一直阻塞在recv()或read()调用上。当有成千上万个连接时，如果为每个连接分配一个线程，那么成本极高。IO复用则允许你用少量的线程（甚至一个线程）管理大量连接的I/O事件，大幅度提高资源利用率和扩展性。

举例：

使用epoll_wait，主线程可以阻塞在epoll_wait中。当某个连接有数据到来（可读事件）或发送缓冲区空闲（可写事件）时，epoll_wait返回一个已就绪事件列表，我们再处理对应的文件描述符。这就是IO复用的核心思想——多路事件集中管理和分发。

非阻塞I/O是指对文件描述符（如socket）设置非阻塞标志后，对它进行读写操作时，如果数据暂不可用，不会让调用者阻塞等待数据到达或缓冲区可用，而是立即返回一个错误码（例如EAGAIN），告诉你“现在没数据”或者“现在写不了”。这样，你的线程不会因为一次I/O操作而停顿下来，依然可以处理其他任务或等待下一个I/O事件就绪。

在高并发服务器中，非阻塞I/O与IO复用是最佳搭档：

IO复用机制（如epoll）告诉你这个fd已经可读或可写了，你这时执行非阻塞读或写操作。如果读的时候还没读完数据，就继续循环读，直到EAGAIN出现，表示读空了；写的时候也是写到不能再写为止。这样通过一次epoll事件触发，你尽可能彻底地完成数据的传输。这就是为什么ET（边缘触发）模式下需要非阻塞I/O，因为你不会重复收到事件通知，必须一次性把能读的全部读完。

epoll + 非阻塞IO是什么？
epoll是Linux下高效的IO复用机制，它能在大量文件描述符中快速找到有事件发生的描述符，并返回给用户态程序进行处理。非阻塞I/O则是指socket在读写时不会阻塞进程。

组合在一起的工作方式是：

将多个socket（非阻塞模式）注册到epoll中。
主循环调用epoll_wait()阻塞等待事件。
一旦epoll_wait()返回，说明某些socket变得可读或者可写。
此时我们对这些就绪的socket调用read或write，读取或发送尽可能多的数据（在非阻塞模式下，如果数据还没来或缓冲区满了，会返回EAGAIN）。
这样我们在一次事件触发中就能“尽可能”地完成I/O操作，提高效率，避免重复事件或重复等待。

上下文切换：
上下文切换是当操作系统的CPU从执行一个线程（或进程）切换到执行另一个线程（或进程）时，需要保存当前线程的CPU寄存器、程序计数器等状态，然后加载另一个线程的状态，以继续执行该线程的指令的过程。

频繁上下文切换导致性能降低的原因：
上下文切换有开销，包括内存页表切换、CPU缓存失效（cache miss）以及内核管理数据结构的处理。过多的切换会消耗大量CPU时间在管理线程状态上，而不是在实际的工作负载（业务处理）上。

为什么一个线程能管理很多连接？
一个线程并不需要对每个连接都进行"同步"的阻塞等待。借助非阻塞I/O和事件驱动模型（如Reactor），一个线程可以通过epoll等待多个socket事件，并在这些事件就绪时再进行处理。这样，一个线程就可以同时"管理"成百上千个连接。线程其实有"容量"限制，但这个限制不是严格由线程本身决定的，而是由I/O模型和内存/CPU资源决定的。在事件驱动框架下，只要处理逻辑足够简单，单线程就可以高效地循环处理许多连接的I/O事件。

线程通过epoll管理多个事件时的行为，多事件同时就绪怎么办？多线程又是如何应对高并发场景的？

单线程 + epoll的工作流程：
一个线程调用epoll_wait()等待事件就绪。当epoll_wait()返回时，会给出一个事件列表（多个就绪的文件描述符及其事件类型）。然后该线程会按照一定策略（通常是顺序或基于优先级）对这些就绪事件进行处理。
若在处理一个事件的过程中，其他连接再次有新事件就绪，这些事件不会丢失——内核会将它们记录在epoll的事件队列中，待当前处理结束后，线程再次调用epoll_wait()（或者在循环中）会再次获得这些事件并进行处理。
简而言之，当多个事件几乎同时就绪时，epoll_wait()一次返回中就会包含它们，线程会依次处理。当正在处理一个事件时又有新事件就绪，这些新事件将会在下一次epoll_wait()调用中被返回，或者如果你是循环调用epoll_wait()的话，会在下一轮中被处理。一个线程并非同时处理多个事件，而是串行地依次处理就绪事件队列里的事件。

多线程 + epoll的场景：
在高并发服务器中，可以有多种策略：

主线程监听，工作线程处理：主线程负责调用epoll_wait()获取就绪事件，然后将事件分发给线程池中的工作线程异步处理。这相当于把事件的处理从监听线程中解耦开来。

每个工作线程各自拥有epoll实例（或使用 epoll_create() 创建的多路复用器）：多线程各自监听一部分socket或使用某种负载均衡机制来分配FD给不同线程管理。这样每个线程处理自己的事件集。

不管哪种方式，通过适当的负载均衡和线程池机制，可以同时处理大量连接。即使有多个事件同时就绪，不同线程分工明确，一次epoll_wait()返回的多个事件可分配给多个线程并行处理，从而应对高并发。

### `<functional>`
`function`是cpp11中引入的一个通用多态的函数封装器，是`functional`头文件中提供的模板，用来统一封装具有同种返回值、参数类型但不同的可调用对象（函数、lambda等）

语法：`std::function<返回类型(参数类型列表)> 可调用对象名`

### typedef
`typedef`是cpp11新特性，用于为现有数据类型创建别名，但在现代cpp中，大多使用using

    typedef std::function<void()> Function;

    using Function = std::function<void()>; //等同于使用typedef

### `<mutex>`
什么是线程安全的队列/回调列表？
在多线程环境下，如果多个线程要向同一个队列中插入任务（回调函数等），那么就必须保护这个队列的访问防止数据竞争与不一致。例如：

使用std::mutex对队列操作加锁，确保一次只有一个线程可以读写队列。
或使用无锁结构（如atomic + lock-free队列）保证线程安全。
在eventLoop中经常使用一个std::vector<std::function<void()>>存放需要在Loop所属的线程里执行的回调函数。如果其他线程要向这个vector中添加回调，就必须加锁保护，以保证多线程安全，然后通过eventfd唤醒eventLoop线程执行这些回调。

这就是线程安全的队列/回调列表的含义：多线程并发情况下，对存放回调的容器进行互斥保护，从而安全地跨线程提交任务。

### `<thread>`


### `<chrono>`
std::chrono是C++11引入的时间库，用于以强类型和高精度的方式处理时间点（time_point）、时间间隔（duration）和时钟（steady_clock、system_clock）。它提供比传统C时间函数更安全、直观的时间处理方式。

### `<memory>` 智能指针
循环引用问题：
假设EventLoop里有一个std::shared_ptr<channel>的map（channel_map_）。Channel又持有EventLoop的shared_ptr或shared_ptr指向与EventLoop相关的资源，这样就有可能形成一个循环引用（A中持有shared_ptr指向B，B中持有shared_ptr指向A，导致引用计数无法归零，对象无法析构，产生内存泄漏）。

如果在channel_map_中存储weak_ptr<channel>，则不会增加Channel对象的引用计数。当channel对应的shared_ptr在其他地方释放后，这个weak_ptr不会阻止channel析构。查询时可以用lock()获取有效shared_ptr，若对象已被析构则返回空，这样避免循环引用问题。

weak_ptr<>是什么？
std::weak_ptr是C++智能指针的一种，它不控制对象生命周期，不增加引用计数，只是“弱引用”。需要对象时通过lock()转为shared_ptr。对象销毁后，weak_ptr会变成空的弱引用，无资源可用。

weak_ptr是C++11引入的智能指针类型之一，它与shared_ptr配合使用。
当你用shared_ptr管理对象时，对象的引用计数会随着shared_ptr的复制而增加，当最后一个shared_ptr销毁时，对象才会释放。但如果两个对象通过shared_ptr互相持有对方（例如A持有B的shared_ptr，B持有A的shared_ptr），则会产生循环引用（Reference Cycle），导致内存无法释放。
weak_ptr的作用是打破这种循环引用。weak_ptr不增加底层对象的引用计数，它只是一个弱引用，只有在需要时通过lock()转化为shared_ptr才暂时使用底层对象。如果对象已被销毁，weak_ptr.lock()会返回空的shared_ptr，确保安全使用。这样就可以避免由于互相使用shared_ptr造成的资源无法释放的问题。

## 碎碎念