## 小鹅通-后端开发日常实习一二面凉经
### 一面
#### 问题
**Q：你先做个自我介绍吧**

A：好的，面试官您好，我是来自深圳大学 27 届的某某，我目前是大二在读，然后我是在一家主营业务是海外网文平台的公司做后端开发岗位的实习生，我主要是负责公司的几个代码仓的维护和开发一些新接口，然后学校方面的话，我大一是参加了一个创赛相关的社团，大二目前是在华为智能基座的一个软开部（这里我提社团是因为四月初社团有个小鹅通的绿色通道但我错过了哈哈哈，我是在 boss 上随手投的），大概情况就是这样，我目前也有一个游戏项目在自己写，所以说这次简历上面写的也是它的一个后端服务器的项目，然后我个人的技术栈的话我一开始是学 C++ 出身，然后后面开始学 go，然后由于实习的这家公司他们主要是在用 php 在写他们的业务项目，所以 php 我也有一些了解，然后其他非后端的像前端方面也有一点点了解吧，大概就是这样，谢谢

**Q：嗯，我看你现在是也是还在实习吗？**

A：嗯对

**Q：诶为什么我看你这个二月份开始实习也没多久，为什么要换一份实习？**

A：额主要是因为那个公司现在写的是 php 嘛，然后我个人还是比较想写 go 和 C++ 这方面的，然后因为后端主要是偏 go 的多一些嘛，所以说我现在还是更想写 go 一些，因为 php 它本身我也不是很熟悉嘛，然后它的一些框架呀然后比如说基本的代码语法，或者说它的一些配套的后端的工具什么的，我个人就是实习两个月下来感觉还是没有 go 来的方便和高效一些，然后我个人后面也不太想往 php 这个方向发展，所以说想要换一下然后看到咱们这个小鹅通主要是用 go 的嘛还是

**Q：啊对，主要还是用 go，历史有一些项目是 php，但主要的项目都是用 go，而且 php 的也要同步到 go；好，你是什么时候开始接触 go 的？**

A：嗯是从去年的十一月十二月吧差不多，那个时候是我刚把 C++ 的几个，额也是一个那种类似于 http 框架的项目搞完之后然后就开始接触 go 了，然后开始写 go 的一些项目

**Q：然后你刚刚说 go 和 php 都有一些接触，php 他是单线程的，然后 go 它是可以多线程和多协程的，就是协程、线程和进程它们之间有什么区别？**

A：嗯进程是操作系统它分配资源的最小单位嘛，然后每个进程之间它会有独立的全局变量、堆空间栈空间这种，然后每个进程有自己的寄存器，线程呢就是进程往下细分的一个单位吧，多个线程在进程之间是共享进程的内存空间以及全局变量，但是各个线程之间它又有各自的寄存器和栈空间，然后协程的话其实就是线程再往下细分，因为 go 嘛 go 他的协程相对其他的协程来说会更加自动化一些嘛，它主要是用 goroutine 然后相当于会用 go 的运行时来减少平时操作线程切换上下文的一些开销，然后达到更好应对高并发的目的；然后其实像 php 它也有一些框架是可以用多进程多线程这种

**Q：像 php 也有协程这个概念，有了解吗？**

A：目前我主要就是公司有一个 IM 的项目，是用那个国产的一个叫 gateway-worker 的一个框架，然后它这个框架就相比于像传统的 laravel 还有 workerman，它是更加面向 websocket 和长连接、即时通讯的，它里面就是有一些针对高并发然后来做一些协程

**Q：那像除了 go 和 php，像 C 语言也是有去接触过的对吧？**

A：嗯我对 C 语言接触的不算多，我主要是学 C++ 的，C++ 它也有协程，主要是在标准库里的

**Q：那关于内存管理，比如说像 go 和 php 这种面向对象的高级语言，基本上内存你都不需要自己去申请，然后对应它会有垃圾回收，那为什么它不需要自己去申请内存，它是怎么做到的，以及它的垃圾回收是怎么结合的，可以用 go 来说**

A：go 主要就是用 GC 嘛，然后它自己是有一套内存回收的管理机制的，比如说它，比如最主要就是 GC，然后它会有一个三色的抽象，就是黑白灰，比如说我一个程序开始运行的时候，在运行时 GC 就会去走一个最基本的一个检索，然后会去标记我这个程序里面不同变量的生命周期，在程序运行完之后 GC 会做第二遍扫描，这个扫描的目的主要是为了检查前一次扫描有没有漏的并实际去操作和回收这些生命周期到了的变量，然后它主要是通过黑白灰三个颜色来标记生命周期，像白色的话可能就是我还完全没有标记它，灰色的话是我已经标记了，可能我还没有回收，可能还要过一会才能回收，黑色的话可能就是我已经标记了而且我已经回收完了，主要是通过这种抽象的层次以及配合上它本身比较强大的运行时，这两个做一个结合实现了它一个程序运行时 GC 能够并发地去进行垃圾回收，所以说这种高度抽象的层次可以就是比较方便，可以不用让我们程序员就是像手动地像 C++ 那样去管理某个内存某个变量的回收之类的

###### 感觉自己这里在瞎扯

**Q：那其实你刚刚主要是介绍了一下它的垃圾回收，那我刚刚前面的问题其实其中一问就是为什么不需要自己的去申请它的内存，它是怎么来结合这个垃圾回收的，因为是应该先有前面的才会有这个垃圾回收嘛，所以前面它是怎么做的，这部分能再补充一下吗？**

A：就是比方说我创建了一个变量，我并不需要像 C++ 那样像我在创建变量时就去考虑这个变量可能需要占用多少内存空间，或者是有没有堆栈溢出的风险面经相当于 go 语言它本身，如果拿协程来说，一个 goroutine 本身开销就是非常小的，所以即使我写一个程序，我也不需要特别纠结某一个变量它，不管我用的是 new 还是 make，会不会影响到我目前的栈或者堆，而且它本身对栈的管理也是非常高效的，所以它才配合这个 GC 回收一起来实现这样一个高效自动的内存管理机制

###### 还在瞎扯

**Q：所以垃圾回收主要回收的是堆的还是栈的？**

A：都有吧，像 C++ 里面可能是要自己来回收堆嘛，然后栈由操作系统来回收，但是像 go 里面 GC 其实栈和堆它都是不需要程序员自己手动去操作的就是

###### 被打断

**Q：我就是说 GC 部分就是垃圾回收部分主要回收的是堆还是栈，（再次打断）包括你刚刚的说的三色标记法，它标记的是全局对象还是调用栈**

A：这个我有点不太确定，但我推测标记的应该是堆里面的，因为它更多的是不用操作系统去做一个系统级的回收，然后以此来减少开销的

**Q：那像 go 里面协程间通信或者数据交互的话我们一般用些什么结构？**

A：go 里面主要是用 channel 来实现多个 goroutine 之间的一个通信和同步，然后 channel 又分为有缓存和无缓存，就会看实际业务需求来选用，反正我个人开发的话

###### 被打断

**Q：用 map 可以吗？**

A：嗯 map 我没有用过，这个我不太确定，应该不行吧，我感觉更多还是用 channel 一些

**Q：噢就是没用过所以也不太了解，是吧**

###### 感觉他是理解成我不知道 map 是什么了

A：嗯因为早期 go 里面的 map 它不能保证线程安全嘛，现在的 go 里面如果想要保证高并发安全的话就要用那个标准库里面的那个 sync嘛，或者是自己用锁去写一套来保证线程安全，所以感觉还是用 channel 更方便一些

**Q：嗯用 channel 更方便，但 map 也能用，主要解决你的并发安全，得加锁，对吧？**

A：（我一直点头）

###### 这里面试官对我简历上的项目表示了困惑，因为我写的开发时间跟实习时间是一样的，他以为是游戏公司的项目，我澄清是我自己独立开发的之后就开始围绕项目问了

**Q：你的项目应该有对应的游戏端或者说客户端吧？**

A：有的，客户端的话我目前主要是用前端的一套框架在写，也有在考虑要不要用虚幻五，主要是虚幻五（学习）成本比较高嘛，所以我目前是在边学边写这种状况下

**Q：你这里主要和客户端交互是用 websocket 来做的是吗？**

A：对的，主要是用 websocket 来实现状态同步，然后主要是用服务器来实现端到端的逻辑运算，然后再发到端，端只要负责渲染就可以了

**Q：你这个游戏是个什么类型的游戏？**

A：是个卡牌游戏，是我自己独立设计的

**Q：你刚刚说的 websocket 是状态同步，那你这里面涉及哪些协议，会有哪些交互逻辑？详细介绍一下你这个项目**

A：我这个项目主要是一个卡牌游戏，用户进来会先注册然后登录，然后创建房间，之后匹配，进入到游戏界面之后会有抽牌打牌然后以及分数计算等逻辑，这个服务器主要是用 websocket 来保证各个客户端进入房间之后它的状态是一样的，它能够拿到，比如说对局开始之后，各个客户端都能够获得到这个对局中用户的信息以及其他玩家的信息，主要是用 websocket 然后写了一套 protobuf 来实现这个长连接，websocket 它本身就是这个 http 升级而来的嘛，另外的话注册和登录方面的身份认证主要是用 JWT 来实现的，具体的话就是用户进来之后先注册，注册成功之后会要求用户先登录，如果登录成功，用户密码跟数据库里的密码哈希是一致的话，服务端就会返回一个身份令牌给客户端，客户端在后续的请求中就会附上这个身份令牌，服务器端有一个这种中间件来拦截对于这种有需要认证接口的访问，然后如果说这个身份令牌它上面的信息是一致的话呢就可以实现这个接口的请求，然后服务器还有一个最主要的就是实现刚刚所说的这个分数的计算，因为一些游戏机制它会有这种比如说相对复杂一些的分数计算，或者说这种路由方面的，因为我这个游戏，我要把一张牌放到一张地图上面，地图上有很多格子，我要把牌放到格子上面不同的位置，然后其他玩家也会把牌放到不同的位置，那地图上面这个格子的坐标信息以及牌与牌之间作用得到的分数信息，这个逻辑计算都是由服务端来进行的，然后服务端这边计算完之后还是用 websocket 来返回，当然还是要先压入消息队列里面，然后尽量避免高并发的时候那种压力过大嘛，然后再逐步返回给客户端，然后让客户端实时渲染，服务器端主要就是这几个功能

Q：